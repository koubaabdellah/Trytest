/*
 *   Copyright (c) 2022 Esri
 *   All rights reserved.

 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
define(["require", "exports", "tslib", "esri/core/promiseUtils", "esri/widgets/Expand", "TemplatesCommonLib/functionality/basemapToggle", "esri/geometry/support/jsonUtils", "esri/core/watchUtils", "../utils/printUtils"], function (require, exports, tslib_1, promiseUtils_1, Expand_1, basemapToggle_1, jsonUtils_1, watchUtils_1, printUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchToEditMode = exports.addMeasurement = exports.addExportPDF = exports.addShare = exports.addSearch = exports.addScaleBar = exports.addScreenshot = exports.addSplash = exports.addZoom = exports.addHome = exports.addLocate = exports.addKeyboardShortcuts = exports.addOverlay = exports.addBasemap = void 0;
    Expand_1 = tslib_1.__importDefault(Expand_1);
    function addBasemap(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, basemapTogglePosition, basemapToggle, node, _a, originalBasemap, nextBasemap, BasemapToggle, bmToggle;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        basemapTogglePosition = config.basemapTogglePosition, basemapToggle = config.basemapToggle;
                        node = view.ui.find("basemapWidget");
                        return [4 /*yield*/, (0, basemapToggle_1.getBasemaps)(props)];
                    case 1:
                        _a = _b.sent(), originalBasemap = _a.originalBasemap, nextBasemap = _a.nextBasemap;
                        // If basemapToggle isn't enabled remove the widget if it exists and exit 
                        if (!basemapToggle) {
                            if (node) {
                                view.ui.remove(node);
                                node.destroy();
                            }
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_1, reject_1) { require(["esri/widgets/BasemapToggle"], resolve_1, reject_1); }).then(tslib_1.__importStar)];
                    case 2:
                        BasemapToggle = _b.sent();
                        if (!BasemapToggle)
                            return [2 /*return*/];
                        // Move the basemap toggle widget if it exists 
                        if (propertyName === "basemapTogglePosition" && node) {
                            view.ui.move(node, basemapTogglePosition);
                        }
                        // Add the basemap toggle widget if its enabled or if a different basemap was 
                        // specified
                        if (propertyName === "basemapToggle" && !node) {
                            bmToggle = new BasemapToggle.default({
                                view: view,
                                nextBasemap: nextBasemap,
                                id: "basemapWidget"
                            });
                            (0, basemapToggle_1.resetBasemapsInToggle)(bmToggle, originalBasemap, nextBasemap);
                            view.ui.add(bmToggle, basemapTogglePosition);
                        }
                        else if (node && (propertyName === "nextBasemap" || propertyName === "basemapSelector")) {
                            if (propertyName === "nextBasemap" || propertyName === "basemapSelector") {
                                (0, basemapToggle_1.resetBasemapsInToggle)(node, originalBasemap, nextBasemap);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addBasemap = addBasemap;
    function _findNode(className) {
        var mainNodes = document.getElementsByClassName(className);
        var node = null;
        for (var j = 0; j < mainNodes.length; j++) {
            node = mainNodes[j];
        }
        return node ? node : null;
    }
    function _getBasemap(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var Basemap, basemap;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve_2, reject_2) { require(["esri/Basemap"], resolve_2, reject_2); }).then(tslib_1.__importStar)];
                    case 1:
                        Basemap = _a.sent();
                        if (!Basemap) {
                            return [2 /*return*/];
                        }
                        basemap = Basemap.default.fromId(id);
                        if (!!basemap) return [3 /*break*/, 3];
                        return [4 /*yield*/, new Basemap.default({
                                portalItem: {
                                    id: id
                                }
                            }).loadAll()];
                    case 2:
                        basemap = _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, basemap];
                }
            });
        });
    }
    function addOverlay(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, disableScroll, node, ScrollOverlay, overlay;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config;
                        disableScroll = config.disableScroll;
                        node = _findNode("scroll-overlay");
                        if (!!disableScroll) return [3 /*break*/, 1];
                        if (node)
                            view.ui.remove(node);
                        // update view nav 
                        view.navigation.mouseWheelZoomEnabled = true;
                        view.navigation.browserTouchPanEnabled = true;
                        return [2 /*return*/];
                    case 1: return [4 /*yield*/, new Promise(function (resolve_3, reject_3) { require(["../ui/ScrollOverlay"], resolve_3, reject_3); }).then(tslib_1.__importStar)];
                    case 2:
                        ScrollOverlay = _a.sent();
                        overlay = new ScrollOverlay.default(tslib_1.__assign(tslib_1.__assign({}, props), { container: document.createElement("div") }));
                        view.ui.add(overlay, "manual");
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    }
    exports.addOverlay = addOverlay;
    function addKeyboardShortcuts(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, keyboardShortcuts, appBundle, bundle, Keyboard, node, content, keyboardExpand;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        keyboardShortcuts = config.keyboardShortcuts, appBundle = config.appBundle, bundle = config.bundle;
                        return [4 /*yield*/, new Promise(function (resolve_4, reject_4) { require(["../ui/Keyboard"], resolve_4, reject_4); }).then(tslib_1.__importStar)];
                    case 1:
                        Keyboard = _a.sent();
                        node = view.ui.find("keyboardExpand");
                        if (!keyboardShortcuts) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        if (propertyName === "keyboardShortcuts") {
                            content = new Keyboard.default(props);
                            keyboardExpand = new Expand_1.default({
                                id: "keyboardExpand",
                                content: content,
                                mode: "floating",
                                expandIconClass: "custom-keyboard-icon",
                                view: view
                            });
                            keyboardExpand.collapseTooltip = "".concat(appBundle.open, " ").concat(bundle.generalShortcuts.menu);
                            keyboardExpand.expandTooltip = "".concat(appBundle.open, " ").concat(bundle.generalShortcuts.menu);
                            view.ui.add(keyboardExpand, { position: "top-left", index: 0 });
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addKeyboardShortcuts = addKeyboardShortcuts;
    function addLocate(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, locateWidget, locateWidgetPosition, Locate, node;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        locateWidget = config.locateWidget, locateWidgetPosition = config.locateWidgetPosition;
                        return [4 /*yield*/, new Promise(function (resolve_5, reject_5) { require(['esri/widgets/Locate'], resolve_5, reject_5); }).then(tslib_1.__importStar)];
                    case 1:
                        Locate = _a.sent();
                        node = _findNode("esri-locate");
                        if (!locateWidget) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        if (node && !locateWidget)
                            view.ui.remove(node);
                        if (propertyName === "locateWidgetPosition" && node) {
                            view.ui.move(node, locateWidgetPosition);
                        }
                        else if (propertyName === "locateWidget") {
                            view.ui.add(new Locate.default({ view: view }), locateWidgetPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addLocate = addLocate;
    function addHome(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, home, homePosition, node, Home;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        home = config.home, homePosition = config.homePosition;
                        node = _findNode("esri-home");
                        if (!home) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_6, reject_6) { require(["esri/widgets/Home"], resolve_6, reject_6); }).then(tslib_1.__importStar)];
                    case 1:
                        Home = _a.sent();
                        if (node && !home)
                            view.ui.remove(node);
                        if (propertyName === "homePosition" && node) {
                            view.ui.move(node, homePosition);
                        }
                        else if (propertyName === "home") {
                            view.ui.add(new Home.default({ view: view }), homePosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addHome = addHome;
    function addZoom(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, mapZoom, mapZoomPosition, node, Zoom;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        mapZoom = config.mapZoom, mapZoomPosition = config.mapZoomPosition;
                        node = _findNode("esri-zoom");
                        if (!mapZoom) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        if (node && !mapZoom)
                            view.ui.remove(node);
                        return [4 /*yield*/, new Promise(function (resolve_7, reject_7) { require(["esri/widgets/Zoom"], resolve_7, reject_7); }).then(tslib_1.__importStar)];
                    case 1:
                        Zoom = _a.sent();
                        if (propertyName === "mapZoomPosition" && node) {
                            view.ui.move(node, mapZoomPosition);
                        }
                        else if (propertyName === "mapZoom" && !node) {
                            view.ui.add(new Zoom.default({ view: view }), mapZoomPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addZoom = addZoom;
    function addSplash(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, splash, splashButtonPosition, info, appBundle, bundle, node, infoNode, SplashPanel, panel_1, splashButton;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        splash = config.splash, splashButtonPosition = config.splashButtonPosition, info = config.info, appBundle = config.appBundle, bundle = config.bundle;
                        node = view.ui.find("splashButton");
                        infoNode = view.ui.find("infoExpand");
                        if (infoNode) {
                            view.ui.remove(infoNode);
                        }
                        if (!splash) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_8, reject_8) { require(["../ui/Splash"], resolve_8, reject_8); }).then(tslib_1.__importStar)];
                    case 1:
                        SplashPanel = _a.sent();
                        // move the node if it exists 
                        if (propertyName === "splashButtonPosition") {
                            view.ui.move(node, splashButtonPosition);
                        }
                        else if (propertyName === "splash" && !info) {
                            panel_1 = new SplashPanel.default(props);
                            view.ui.add(panel_1, "manual");
                            splashButton = document.createElement("button");
                            splashButton.classList.add("esri-splash-button", "esri-icon-description", "esri-widget--button", "esri-widget", "esri-interactive");
                            splashButton.title = bundle.tools.splash;
                            splashButton.id = "splashButton";
                            view.ui.add(splashButton, splashButtonPosition);
                            splashButton.addEventListener("click", function () {
                                panel_1.open();
                            });
                        }
                        else if (node && propertyName === "splashFullScreen") {
                            node.setAttribute("fullscreen", "");
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addSplash = addSplash;
    function addScreenshot(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, screenshot, screenshotPosition, legendPanel, popupPanel, popupHover, node, Screenshot, group, content, tip, screenshotExpand_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        screenshot = config.screenshot, screenshotPosition = config.screenshotPosition, legendPanel = config.legendPanel, popupPanel = config.popupPanel, popupHover = config.popupHover;
                        node = view.ui.find("screenshotExpand");
                        if (!screenshot) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_9, reject_9) { require(["Components/Screenshot/Screenshot"], resolve_9, reject_9); }).then(tslib_1.__importStar)];
                    case 1:
                        Screenshot = _a.sent();
                        group = _getPosition(screenshotPosition);
                        if (propertyName === "screenshotPosition" && node) {
                            view.ui.move(node, screenshotPosition);
                            node.group = group;
                        }
                        else if (propertyName === "screenshot") {
                            content = new Screenshot.default({
                                view: view,
                                enableLegendOption: legendPanel ? true : false,
                                enablePopupOption: (popupPanel || popupHover) ? false : true,
                                includeLayoutOption: (popupPanel || popupHover) ? false : true,
                                includePopupInScreenshot: false,
                                includeLegendInScreenshot: legendPanel ? true : false
                            });
                            if (popupPanel) {
                                content.disableCustom = true;
                                content.includeCustomInScreenshot = false;
                                content.custom = {
                                    label: config.appBundle.popupPanel.label,
                                    element: document.getElementById("offscreenResults")
                                };
                            }
                            tip = "".concat(config.bundle.tools.screenshot);
                            screenshotExpand_1 = new Expand_1.default({
                                id: "screenshotExpand",
                                content: content,
                                group: group,
                                mode: "floating",
                                expandTooltip: tip,
                                collapseTooltip: tip,
                                view: view
                            });
                            view.ui.add(screenshotExpand_1, screenshotPosition);
                            (0, watchUtils_1.whenTrueOnce)(screenshotExpand_1, "expanded", function () {
                                var sw = screenshotExpand_1.content;
                                if (!sw)
                                    return;
                                (0, watchUtils_1.whenTrue)(sw, "screenshotModeIsActive", function () {
                                    var _a;
                                    if (sw.includeCustomInScreenshot) {
                                        // copy results to the offscreen container
                                        var container = (_a = sw === null || sw === void 0 ? void 0 : sw.custom) === null || _a === void 0 ? void 0 : _a.element;
                                        if (container) {
                                            (0, printUtils_1.renderPopupContent)(container);
                                        }
                                    }
                                });
                            });
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addScreenshot = addScreenshot;
    function addScaleBar(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, portal, config, propertyName, scalebar, scalebarPosition, node, ScaleBar;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, portal = props.portal, config = props.config, propertyName = props.propertyName;
                        scalebar = config.scalebar, scalebarPosition = config.scalebarPosition;
                        node = _findNode("esri-scale-bar");
                        if (!scalebar) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_10, reject_10) { require(["esri/widgets/ScaleBar"], resolve_10, reject_10); }).then(tslib_1.__importStar)];
                    case 1:
                        ScaleBar = _a.sent();
                        if (propertyName === "scalebarPosition" && node) {
                            view.ui.move(node, scalebarPosition);
                        }
                        else if (propertyName === "scalebar") {
                            view.ui.add(new ScaleBar.default({
                                view: view,
                                unit: (portal === null || portal === void 0 ? void 0 : portal.units) === "metric" ? portal === null || portal === void 0 ? void 0 : portal.units : "non-metric"
                            }), scalebarPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addScaleBar = addScaleBar;
    function addSearch(props) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, portal, config, propertyName, search, popupHover, popupPanel, searchPosition, searchOpenAtStart, extentSelector, extentSelectorConfig, searchConfiguration, node, modules, _b, Search, FeatureLayer, Expand, group, sources, extent_1, geometry, content_1, handle_1, tip, searchExpand;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        view = props.view, portal = props.portal, config = props.config, propertyName = props.propertyName;
                        search = config.search, popupHover = config.popupHover, popupPanel = config.popupPanel, searchPosition = config.searchPosition, searchOpenAtStart = config.searchOpenAtStart, extentSelector = config.extentSelector, extentSelectorConfig = config.extentSelectorConfig;
                        searchConfiguration = config.searchConfiguration;
                        node = view.ui.find("searchExpand");
                        if (!search) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, (0, promiseUtils_1.eachAlways)([new Promise(function (resolve_11, reject_11) { require(["esri/widgets/Search"], resolve_11, reject_11); }).then(tslib_1.__importStar), new Promise(function (resolve_12, reject_12) { require(["esri/layers/FeatureLayer"], resolve_12, reject_12); }).then(tslib_1.__importStar), new Promise(function (resolve_13, reject_13) { require(["esri/widgets/Expand"], resolve_13, reject_13); }).then(tslib_1.__importStar)])];
                    case 1:
                        modules = _c.sent();
                        _b = modules.map(function (module) { return module.value; }), Search = _b[0], FeatureLayer = _b[1], Expand = _b[2];
                        if (!Search || !FeatureLayer || !Expand)
                            return [2 /*return*/];
                        group = _getPosition(searchPosition);
                        if (propertyName === "searchPosition" && node) {
                            // move the node if it exists we have to type as any here 
                            // due to a doc issue with move once index is doc'd remove 
                            view.ui.move(node, searchPosition);
                            node.group = group;
                        }
                        else if (propertyName === "searchOpenAtStart" && node) {
                            node.expanded = searchOpenAtStart;
                        }
                        else if (propertyName === "search" || (propertyName === "extentSelector" && node) || (node && propertyName === "extentSelector") || (propertyName === "searchConfiguration" && node)) {
                            if (node)
                                view.ui.remove(node);
                            sources = searchConfiguration === null || searchConfiguration === void 0 ? void 0 : searchConfiguration.sources;
                            if (sources) {
                                extent_1 = null;
                                if (extentSelector) {
                                    geometry = ((_a = extentSelectorConfig === null || extentSelectorConfig === void 0 ? void 0 : extentSelectorConfig.constraints) === null || _a === void 0 ? void 0 : _a.geometry) || null;
                                    if (geometry) {
                                        extent_1 = (0, jsonUtils_1.fromJSON)(geometry);
                                    }
                                }
                                sources.forEach(function (source) {
                                    var _a, _b, _c;
                                    var sourceLayer = null;
                                    if ((_a = source === null || source === void 0 ? void 0 : source.layer) === null || _a === void 0 ? void 0 : _a.id)
                                        sourceLayer = view.map.findLayerById(source.layer.id);
                                    if (!sourceLayer && ((_b = source === null || source === void 0 ? void 0 : source.layer) === null || _b === void 0 ? void 0 : _b.url)) {
                                        sourceLayer = new FeatureLayer.default((_c = source === null || source === void 0 ? void 0 : source.layer) === null || _c === void 0 ? void 0 : _c.url);
                                    }
                                    source.outFields = ["*"];
                                    source.layer = sourceLayer;
                                    if (extent_1 && ((extent_1 === null || extent_1 === void 0 ? void 0 : extent_1.type) === "extent" || (extent_1 === null || extent_1 === void 0 ? void 0 : extent_1.type) === "polygon")) {
                                        source.filter = {
                                            geometry: extent_1
                                        };
                                    }
                                    else {
                                        source.filter = null;
                                    }
                                });
                            }
                            if (searchConfiguration === undefined || searchConfiguration === null) {
                                searchConfiguration = {
                                    includeDefaultSources: true
                                };
                            }
                            content_1 = new Search.default(tslib_1.__assign({ view: view, portal: portal }, searchConfiguration));
                            handle_1 = content_1 === null || content_1 === void 0 ? void 0 : content_1.viewModel.watch('state', function (state) {
                                if (state === 'ready') {
                                    handle_1.remove();
                                    (0, watchUtils_1.whenDefinedOnce)(content_1, "allPlaceholder", function () {
                                        content_1.allSources.forEach(function (s) {
                                            if (s.placeholder === "") {
                                                s.placeholder = content_1.allPlaceholder;
                                            }
                                        });
                                    });
                                }
                            });
                            content_1.on("search-complete", function () {
                                if (content_1.popupEnabled) {
                                    // Handle setting focus on popup and then back 
                                    // to search box 
                                    if (popupHover)
                                        view.popup.autoOpenEnabled = true;
                                    (0, watchUtils_1.whenTrueOnce)(view.popup.viewModel, "active", function () {
                                        view.popup.focus();
                                        (0, watchUtils_1.whenFalseOnce)(view.popup, "visible", function () {
                                            content_1.focus();
                                            if (popupHover)
                                                view.popup.autoOpenEnabled = false;
                                        });
                                    });
                                }
                                if (popupPanel) {
                                    var clickHandler_1 = view.on("click", function () {
                                        clickHandler_1.remove();
                                        if (content_1.searchTerm) {
                                            content_1.clear();
                                        }
                                        ;
                                    });
                                }
                            });
                            tip = "".concat(config.bundle.tools.search);
                            searchExpand = new Expand.default({
                                expanded: searchOpenAtStart,
                                id: "searchExpand",
                                content: content_1,
                                group: group,
                                collapseTooltip: tip,
                                expandTooltip: tip,
                                mode: "floating",
                                view: view
                            });
                            view.ui.add(searchExpand, searchPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addSearch = addSearch;
    function addShare(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, share, shareIncludeSocial, header, node, Share, shareExpand;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        share = config.share, shareIncludeSocial = config.shareIncludeSocial, header = config.header;
                        node = view.ui.find("shareMap");
                        // Remove the widget if share isdisabled or if header is enabled
                        if (!share || (header && node)) {
                            if (node) {
                                view.ui.remove(node);
                                node.destroy();
                            }
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_14, reject_14) { require(["../ui/Share"], resolve_14, reject_14); }).then(tslib_1.__importStar)];
                    case 1:
                        Share = _a.sent();
                        if (!Share)
                            return [2 /*return*/];
                        // Only add sharing to view if header is false 
                        if ((propertyName === "share" || propertyName === "header") && !header && !node) {
                            shareExpand = new Expand_1.default({
                                id: "shareMap",
                                content: new Share.default({ view: view, config: config }),
                                mode: "floating",
                                expandIconClass: "esri-icon-share2",
                                view: view
                            });
                            if (!view.ui.find("shareMap")) {
                                view.ui.add(shareExpand, "top-right");
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addShare = addShare;
    function addExportPDF(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, exportPDF, header, appBundle, node, button;
            return tslib_1.__generator(this, function (_a) {
                view = props.view, config = props.config, propertyName = props.propertyName;
                exportPDF = config.exportPDF, header = config.header, appBundle = config.appBundle;
                node = view.ui.find("exportPDF");
                // Remove the widget if share isdisabled or if header is enabled
                if (!exportPDF || (header && node)) {
                    if (node)
                        view.ui.remove(node);
                    return [2 /*return*/];
                }
                if ((propertyName === "exportPDF" || propertyName === "header") && !header && !node) {
                    if (!view.ui.find("exportPDF")) {
                        button = document.createElement("calcite-button");
                        button.id = "exportPDF";
                        button.title = appBundle.tools.exportTip;
                        button.label = appBundle.tools.exportTip;
                        button.classList.add("pdf-share", "esri-component", "esri-widget--button", "esri-widget");
                        button.alignment = "end";
                        button.appearance = "solid";
                        button.color = "neutral";
                        button.iconStart = "file-pdf";
                        button.onclick = function () {
                            (0, printUtils_1.takeScreenshotAndPrint)(props).then(function () {
                                setTimeout(function () {
                                    window.print();
                                }, 1000);
                            });
                        };
                        view.ui.add(button, "top-right");
                    }
                }
                return [2 /*return*/];
            });
        });
    }
    exports.addExportPDF = addExportPDF;
    function _getPosition(position) {
        // object or string 
        var groupName = null;
        if (typeof position === "string") {
            groupName = position;
        }
        else if (position === null || position === void 0 ? void 0 : position.position) {
            groupName = position.position;
        }
        return groupName;
    }
    function addMeasurement(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, measure, measurePosition, measureOpenAtStart, appBundle, bundle, node, modules, MeasurePanel, group, mv, content_2, measureExpand_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        measure = config.measure, measurePosition = config.measurePosition, measureOpenAtStart = config.measureOpenAtStart, appBundle = config.appBundle, bundle = config.bundle;
                        node = view.ui.find("measureExpand");
                        if (!measure) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, (0, promiseUtils_1.eachAlways)([new Promise(function (resolve_15, reject_15) { require(["../ui/MeasurePanel"], resolve_15, reject_15); }).then(tslib_1.__importStar)])];
                    case 1:
                        modules = _a.sent();
                        MeasurePanel = modules.map(function (module) { return module.value; })[0];
                        group = _getPosition(measurePosition);
                        if ((propertyName === "measurePosition" || propertyName === "measureOpenAtStart") && node) {
                            if (propertyName === "measureOpenAtStart") {
                                measureOpenAtStart ? node.expand() : node.collapse();
                            }
                            if (propertyName === "measurePosition") {
                                view.ui.move(node, measurePosition);
                                node.group = group;
                            }
                        }
                        else if (propertyName === "measure") {
                            mv = view;
                            content_2 = new MeasurePanel.default({
                                config: config,
                                view: mv
                            });
                            measureExpand_1 = new Expand_1.default({
                                id: "measureExpand",
                                content: content_2,
                                group: group,
                                expandIconClass: "esri-icon-measure",
                                mode: "floating",
                                view: view
                            });
                            content_2.watch("measureTip", function () {
                                var tip = "".concat(appBundle.open, " ").concat(content_2.measureTip);
                                measureExpand_1.expandTooltip = tip;
                                measureExpand_1.collapseTooltip = tip;
                            });
                            if (measureOpenAtStart)
                                measureExpand_1.expand();
                            view.ui.add(measureExpand_1, measurePosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addMeasurement = addMeasurement;
    function switchToEditMode(graphic, editor, view) {
        if (editor && graphic) {
            // switch to edit panel
            var isMobile = window.matchMedia("(max-width: 700px)");
            var actionExpression = (isMobile === null || isMobile === void 0 ? void 0 : isMobile.matches) ? "calcite-radio-group-item[data-action-item='edit']" : "calcite-action[data-action-item='edit']";
            var action = document.querySelector(actionExpression);
            var notActive = (view.widthBreakpoint === "xsmall") ? !action.hasAttribute("checked") : !action.hasAttribute("active");
            if (action && notActive) {
                if (isMobile === null || isMobile === void 0 ? void 0 : isMobile.matches) {
                    action.checked = true;
                    action.click();
                }
                else {
                    action.click();
                }
            }
            ;
            editor.startUpdateWorkflowAtFeatureEdit(graphic);
        }
    }
    exports.switchToEditMode = switchToEditMode;
});
