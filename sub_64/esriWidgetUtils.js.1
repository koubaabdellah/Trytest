/*
 *   Copyright (c) 2022 Esri
 *   All rights reserved.

 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
define(["require", "exports", "tslib", "esri/core/promiseUtils", "esri/widgets/Expand", "TemplatesCommonLib/functionality/basemapToggle", "esri/geometry/support/jsonUtils", "esri/core/watchUtils", "TemplatesCommonLib/structuralFunctionality/t9nUtils"], function (require, exports, tslib_1, promiseUtils_1, Expand_1, basemapToggle_1, jsonUtils_1, watchUtils_1, t9nUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addSearch = exports.addLegend = exports.addLayerList = exports.addOverlay = exports.addBookmarks = exports.addScreenshot = exports.addShare = exports.addFullscreen = exports.addScaleBar = exports.addZoom = exports.addHome = exports.addLocate = exports.addBasemap = void 0;
    Expand_1 = tslib_1.__importDefault(Expand_1);
    var bundleName = "media/app/t9n/common";
    function addBasemap(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, basemapTogglePosition, basemapToggle, node, _a, originalBasemap, nextBasemap, BasemapToggle, bmToggle;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        basemapTogglePosition = config.basemapTogglePosition, basemapToggle = config.basemapToggle;
                        node = view.ui.find("basemapWidget");
                        return [4 /*yield*/, basemapToggle_1.getBasemaps(props)];
                    case 1:
                        _a = _b.sent(), originalBasemap = _a.originalBasemap, nextBasemap = _a.nextBasemap;
                        // If basemapToggle isn't enabled remove the widget if it exists and exit 
                        if (!basemapToggle) {
                            if (node) {
                                view.ui.remove(node);
                                node.destroy();
                            }
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_1, reject_1) { require(["esri/widgets/BasemapToggle"], resolve_1, reject_1); }).then(tslib_1.__importStar)];
                    case 2:
                        BasemapToggle = _b.sent();
                        if (!BasemapToggle)
                            return [2 /*return*/];
                        // Move the basemap toggle widget if it exists 
                        if (propertyName === "basemapTogglePosition" && node) {
                            view.ui.move(node, basemapTogglePosition);
                        }
                        // Add the basemap toggle widget if its enabled or if a different basemap was 
                        // specified
                        if (propertyName === "basemapToggle" && !node) {
                            bmToggle = new BasemapToggle.default({
                                view: view,
                                nextBasemap: nextBasemap,
                                id: "basemapWidget"
                            });
                            basemapToggle_1.resetBasemapsInToggle(bmToggle, originalBasemap, nextBasemap);
                            view.ui.add(bmToggle, basemapTogglePosition);
                        }
                        else if (node && (propertyName === "nextBasemap" || propertyName === "basemapSelector")) {
                            if (propertyName === "nextBasemap" || propertyName === "basemapSelector") {
                                basemapToggle_1.resetBasemapsInToggle(node, originalBasemap, nextBasemap);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addBasemap = addBasemap;
    function _findNode(className) {
        var mainNodes = document.getElementsByClassName(className);
        var node = null;
        for (var j = 0; j < mainNodes.length; j++) {
            node = mainNodes[j];
        }
        return node ? node : null;
    }
    function _getBasemap(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var Basemap, basemap;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve_2, reject_2) { require(["esri/Basemap"], resolve_2, reject_2); }).then(tslib_1.__importStar)];
                    case 1:
                        Basemap = _a.sent();
                        if (!Basemap) {
                            return [2 /*return*/];
                        }
                        basemap = Basemap.default.fromId(id);
                        if (!!basemap) return [3 /*break*/, 3];
                        return [4 /*yield*/, new Basemap.default({
                                portalItem: {
                                    id: id
                                }
                            }).loadAll()];
                    case 2:
                        basemap = _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, basemap];
                }
            });
        });
    }
    function addLocate(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, locateWidget, locateWidgetPosition, Locate, node;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        locateWidget = config.locateWidget, locateWidgetPosition = config.locateWidgetPosition;
                        return [4 /*yield*/, new Promise(function (resolve_3, reject_3) { require(['esri/widgets/Locate'], resolve_3, reject_3); }).then(tslib_1.__importStar)];
                    case 1:
                        Locate = _a.sent();
                        node = _findNode("esri-locate");
                        if (!locateWidget) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        if (node && !locateWidget)
                            view.ui.remove(node);
                        if (propertyName === "locateWidgetPosition" && node) {
                            view.ui.move(node, locateWidgetPosition);
                        }
                        else if (propertyName === "locateWidget") {
                            view.ui.add(new Locate.default({ view: view }), locateWidgetPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addLocate = addLocate;
    function addHome(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, home, homePosition, node, Home;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        home = config.home, homePosition = config.homePosition;
                        node = _findNode("esri-home");
                        if (!home) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        if (node && !home)
                            view.ui.remove(node);
                        return [4 /*yield*/, new Promise(function (resolve_4, reject_4) { require(["esri/widgets/Home"], resolve_4, reject_4); }).then(tslib_1.__importStar)];
                    case 1:
                        Home = _a.sent();
                        if (propertyName === "homePosition" && node) {
                            view.ui.move(node, homePosition);
                        }
                        else if (propertyName === "home") {
                            view.ui.add(new Home.default({ view: view }), homePosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addHome = addHome;
    function addZoom(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, mapZoom, mapZoomPosition, node, index, Zoom;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        mapZoom = config.mapZoom, mapZoomPosition = config.mapZoomPosition;
                        node = _findNode("esri-zoom");
                        if (!mapZoom) {
                            if (node)
                                view.ui.remove(node);
                            index = view.ui.components.indexOf("zoom");
                            if (index > -1) {
                                view.ui.components.splice(index, 1);
                            }
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_5, reject_5) { require(["esri/widgets/Zoom"], resolve_5, reject_5); }).then(tslib_1.__importStar)];
                    case 1:
                        Zoom = _a.sent();
                        if (node && !mapZoom)
                            view.ui.remove(node);
                        if (propertyName === "mapZoomPosition" && node) {
                            view.ui.move(node, mapZoomPosition);
                        }
                        else if (propertyName === "mapZoom" && !node) {
                            view.ui.add(new Zoom.default({ view: view }), mapZoomPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addZoom = addZoom;
    function addScaleBar(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, portal, config, propertyName, scalebar, scalebarPosition, node, ScaleBar;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, portal = props.portal, config = props.config, propertyName = props.propertyName;
                        scalebar = config.scalebar, scalebarPosition = config.scalebarPosition;
                        node = _findNode("esri-scale-bar");
                        if (!scalebar) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_6, reject_6) { require(["esri/widgets/ScaleBar"], resolve_6, reject_6); }).then(tslib_1.__importStar)];
                    case 1:
                        ScaleBar = _a.sent();
                        // move the node if it exists 
                        if (propertyName === "scalebarPosition" && node) {
                            view.ui.move(node, scalebarPosition);
                        }
                        else if (propertyName === "scalebar") {
                            view.ui.add(new ScaleBar.default({
                                view: view,
                                unit: (portal === null || portal === void 0 ? void 0 : portal.units) === "metric" ? portal === null || portal === void 0 ? void 0 : portal.units : "non-metric"
                            }), scalebarPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addScaleBar = addScaleBar;
    function addFullscreen(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, fullScreen, fullScreenPosition, node, Fullscreen;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        fullScreen = config.fullScreen, fullScreenPosition = config.fullScreenPosition;
                        node = _findNode("esri-fullscreen");
                        if (!fullScreen) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_7, reject_7) { require(["esri/widgets/Fullscreen"], resolve_7, reject_7); }).then(tslib_1.__importStar)];
                    case 1:
                        Fullscreen = _a.sent();
                        // move the node if it exists 
                        if (propertyName === "fullScreenPosition" && node) {
                            view.ui.move(node, fullScreenPosition);
                        }
                        else if (propertyName === "fullScreen") {
                            view.ui.add(new Fullscreen.default({
                                view: view
                            }), fullScreenPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addFullscreen = addFullscreen;
    function addShare(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, share, sharePosition, node, Share, group, content, shareExpand;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        share = config.share, sharePosition = config.sharePosition;
                        node = view.ui.find("shareMap");
                        // Remove the widget if share isdisabled or if header is enabled
                        if (!share) {
                            if (node) {
                                view.ui.remove(node);
                                node.destroy();
                            }
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_8, reject_8) { require(["../components/Share"], resolve_8, reject_8); }).then(tslib_1.__importStar)];
                    case 1:
                        Share = _a.sent();
                        if (!Share)
                            return [2 /*return*/];
                        group = _getPosition(sharePosition);
                        if (propertyName === "sharePosition" && node) {
                            view.ui.move(node, sharePosition);
                            node.group = group;
                        }
                        else if ((propertyName === "share") && !node) {
                            content = new Share.default({ view: view, config: config });
                            shareExpand = new Expand_1.default({
                                id: "shareMap",
                                content: content,
                                mode: "floating",
                                group: group,
                                expandIconClass: "esri-icon-share2",
                                view: view
                            });
                            if (!view.ui.find("shareMap")) {
                                view.ui.add(shareExpand, sharePosition);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addShare = addShare;
    function addScreenshot(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, screenshot, screenshotPosition, legend, popupHover, bundle, node, Screenshot, group, content, tip, screenshotExpand, ss;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        screenshot = config.screenshot, screenshotPosition = config.screenshotPosition, legend = config.legend, popupHover = config.popupHover, bundle = config.bundle;
                        node = view.ui.find("screenshotExpand");
                        if (!screenshot) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_9, reject_9) { require(["Components/Screenshot/Screenshot"], resolve_9, reject_9); }).then(tslib_1.__importStar)];
                    case 1:
                        Screenshot = _a.sent();
                        group = _getPosition(screenshotPosition);
                        if (propertyName === "screenshotPosition" && node) {
                            view.ui.move(node, screenshotPosition);
                            node.group = group;
                        }
                        else if (propertyName === "screenshot") {
                            content = new Screenshot.default({
                                view: view,
                                enableLegendOption: legend ? true : false,
                                enablePopupOption: popupHover ? false : true,
                                includeLayoutOption: (legend || !popupHover) ? true : false,
                                includePopupInScreenshot: false,
                                includeLegendInScreenshot: false
                            });
                            tip = bundle.tools.toggle + " " + bundle.tools.screenshot;
                            screenshotExpand = new Expand_1.default({
                                id: "screenshotExpand",
                                content: content,
                                mode: "floating",
                                group: group,
                                collapseTooltip: tip,
                                expandTooltip: tip,
                                view: view
                            });
                            view.ui.add(screenshotExpand, screenshotPosition);
                            t9nUtils_1.autoUpdatedStrings.add({ obj: screenshotExpand, property: "collapseTooltip", bundleName: bundleName, key: "tools.screenshot" });
                            t9nUtils_1.autoUpdatedStrings.add({ obj: screenshotExpand, property: "expandTooltip", bundleName: bundleName, key: "tools.screenshot" });
                        }
                        else if (propertyName === "popupHover" && node) {
                            ss = node === null || node === void 0 ? void 0 : node.content;
                            if (ss)
                                ss.enablePopupOption = !popupHover;
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addScreenshot = addScreenshot;
    function addBookmarks(props) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, bookmarks, bookmarksPosition, bundle, type, item, itemType, node, map, mapContainsBookmarks, Bookmarks, _e, group, content, tip, bookmarksExpand;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        bookmarks = config.bookmarks, bookmarksPosition = config.bookmarksPosition, bundle = config.bundle, type = config.type;
                        item = view === null || view === void 0 ? void 0 : view.map;
                        itemType = type;
                        if ((_a = item === null || item === void 0 ? void 0 : item.portalItem) === null || _a === void 0 ? void 0 : _a.type) {
                            itemType = item.portalItem.type === "Web Map" ? "webmap" : "webscene";
                        }
                        node = view.ui.find("bookmarksExpand");
                        if (itemType === "webmap") {
                            map = view.map;
                            mapContainsBookmarks = ((_b = map === null || map === void 0 ? void 0 : map.bookmarks) === null || _b === void 0 ? void 0 : _b.length) > 0 ? true : false;
                        }
                        else {
                            map = view.map;
                            mapContainsBookmarks = ((_d = (_c = map === null || map === void 0 ? void 0 : map.presentation) === null || _c === void 0 ? void 0 : _c.slides) === null || _d === void 0 ? void 0 : _d.length) > 0 ? true : false;
                        }
                        if (!bookmarks || !mapContainsBookmarks) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        if (!(itemType === "webmap")) return [3 /*break*/, 2];
                        return [4 /*yield*/, new Promise(function (resolve_10, reject_10) { require(["esri/widgets/Bookmarks"], resolve_10, reject_10); }).then(tslib_1.__importStar)];
                    case 1:
                        _e = _f.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, new Promise(function (resolve_11, reject_11) { require(["../components/Slides"], resolve_11, reject_11); }).then(tslib_1.__importStar)];
                    case 3:
                        _e = _f.sent();
                        _f.label = 4;
                    case 4:
                        Bookmarks = _e;
                        group = _getPosition(bookmarksPosition);
                        if (propertyName === "bookmarksPosition" && node) {
                            view.ui.move(node, bookmarksPosition);
                            node.group = group;
                        }
                        else if (propertyName === "bookmarks") {
                            content = new Bookmarks.default({
                                view: view,
                                viewModel: {
                                    view: view,
                                    abilities: { time: false }
                                }
                            });
                            tip = "" + bundle.tools.bookmarks;
                            bookmarksExpand = new Expand_1.default({
                                id: "bookmarksExpand",
                                content: content,
                                group: group,
                                collapseTooltip: tip,
                                expandTooltip: tip,
                                mode: "floating",
                                view: view
                            });
                            t9nUtils_1.autoUpdatedStrings.add({ obj: bookmarksExpand, property: "collapseTooltip", bundleName: bundleName, key: "tools.bookmark" });
                            t9nUtils_1.autoUpdatedStrings.add({ obj: bookmarksExpand, property: "expandTooltip", bundleName: bundleName, key: "tools.bookmark" });
                            view.ui.add(bookmarksExpand, bookmarksPosition);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addBookmarks = addBookmarks;
    function addOverlay(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, disableScroll, theme, ScrollOverlay, node, overlay;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        disableScroll = config.disableScroll, theme = config.theme;
                        return [4 /*yield*/, new Promise(function (resolve_12, reject_12) { require(["../components/ScrollOverlay"], resolve_12, reject_12); }).then(tslib_1.__importStar)];
                    case 1:
                        ScrollOverlay = _a.sent();
                        node = _findNode("scroll-overlay");
                        if (!disableScroll) {
                            // update view nav 
                            if (node)
                                view.ui.remove(node);
                            view.navigation.mouseWheelZoomEnabled = true;
                            view.navigation.browserTouchPanEnabled = true;
                            return [2 /*return*/];
                        }
                        else if (propertyName === "disableScroll" && !node) {
                            overlay = new ScrollOverlay.default(tslib_1.__assign(tslib_1.__assign({}, props), { container: document.createElement("div") }));
                            view.ui.add(overlay, "manual");
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addOverlay = addOverlay;
    function addLayerList(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, layerList, layerListPosition, layerListOpenAtStart, layerListAddTable, bundle, node, modules, LayerList, group, content, tip, layerListExpand;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        layerList = config.layerList, layerListPosition = config.layerListPosition, layerListOpenAtStart = config.layerListOpenAtStart, layerListAddTable = config.layerListAddTable, bundle = config.bundle;
                        node = view.ui.find("layerListExpand");
                        if (!layerList) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, promiseUtils_1.eachAlways([new Promise(function (resolve_13, reject_13) { require(["esri/widgets/LayerList"], resolve_13, reject_13); }).then(tslib_1.__importStar)])];
                    case 1:
                        modules = _a.sent();
                        LayerList = modules.map(function (module) { return module.value; })[0];
                        group = _getPosition(layerListPosition);
                        if ((propertyName === "layerListAddTable" || propertyName === "layerListOpenAtStart" || propertyName === "layerListPosition") && node) {
                            if (propertyName === "layerListPosition") {
                                view.ui.move(node, layerListPosition);
                                node.group = group;
                            }
                            if (propertyName === "layerListOpenAtStart")
                                layerListOpenAtStart ? node.expand() : node.collapse();
                        }
                        else if (propertyName === "layerList") {
                            content = new LayerList.default({
                                view: view
                            });
                            tip = "" + bundle.tools.layerList;
                            layerListExpand = new Expand_1.default({
                                id: "layerListExpand",
                                content: content,
                                expandTooltip: tip,
                                collapseTooltip: tip,
                                group: group,
                                mode: "floating",
                                view: view
                            });
                            if (layerListOpenAtStart)
                                layerListExpand.expand();
                            view.ui.add(layerListExpand, layerListPosition);
                            t9nUtils_1.autoUpdatedStrings.add({ obj: layerListExpand, property: "collapseTooltip", bundleName: bundleName, key: "tools.layerList" });
                            t9nUtils_1.autoUpdatedStrings.add({ obj: layerListExpand, property: "collapseTooltip", bundleName: bundleName, key: "tools.layerList" });
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addLayerList = addLayerList;
    function addLegend(props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, config, propertyName, legend, legendPosition, legendOpenAtStart, bundle, node, Legend, group, content, tip, legendExpand;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        view = props.view, config = props.config, propertyName = props.propertyName;
                        legend = config.legend, legendPosition = config.legendPosition, legendOpenAtStart = config.legendOpenAtStart, bundle = config.bundle;
                        node = view.ui.find("legendExpand");
                        if (!legend) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve_14, reject_14) { require(["esri/widgets/Legend"], resolve_14, reject_14); }).then(tslib_1.__importStar)];
                    case 1:
                        Legend = _a.sent();
                        group = _getPosition(legendPosition);
                        if ((propertyName === "legendPosition" || propertyName === "legendOpenAtStart") && node) {
                            if (propertyName === "legendOpenAtStart") {
                                legendOpenAtStart ? node.expand() : node.collapse();
                            }
                            if (propertyName === "legendPosition") {
                                view.ui.move(node, legendPosition);
                                node.group = group;
                            }
                        }
                        else if (propertyName === "legend") {
                            content = new Legend.default({
                                view: view
                            });
                            tip = "" + bundle.tools.legend;
                            legendExpand = new Expand_1.default({
                                id: "legendExpand",
                                content: content,
                                group: group,
                                expandTooltip: tip,
                                collapseTooltip: tip,
                                mode: "floating",
                                view: view
                            });
                            if (legendOpenAtStart)
                                legendExpand.expand();
                            view.ui.add(legendExpand, legendPosition);
                            t9nUtils_1.autoUpdatedStrings.add({ obj: legendExpand, property: "expandTooltip", bundleName: bundleName, key: "tools.legend" });
                            t9nUtils_1.autoUpdatedStrings.add({ obj: legendExpand, property: "collapseTooltip", bundleName: bundleName, key: "tools.legend" });
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addLegend = addLegend;
    function addSearch(props) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var view, portal, config, propertyName, bundle, search, popupHover, searchPosition, searchOpenAtStart, extentSelector, extentSelectorConfig, searchConfiguration, node, modules, _c, Search, FeatureLayer, group, sources, extent_1, geometry, content_1, handle_1, tip, searchExpand;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        view = props.view, portal = props.portal, config = props.config, propertyName = props.propertyName;
                        bundle = config.bundle, search = config.search, popupHover = config.popupHover, searchPosition = config.searchPosition, searchOpenAtStart = config.searchOpenAtStart, extentSelector = config.extentSelector, extentSelectorConfig = config.extentSelectorConfig;
                        searchConfiguration = config.searchConfiguration;
                        node = view.ui.find("searchExpand");
                        if (!search) {
                            if (node)
                                view.ui.remove(node);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, promiseUtils_1.eachAlways([new Promise(function (resolve_15, reject_15) { require(["esri/widgets/Search"], resolve_15, reject_15); }).then(tslib_1.__importStar), new Promise(function (resolve_16, reject_16) { require(["esri/layers/FeatureLayer"], resolve_16, reject_16); }).then(tslib_1.__importStar)])];
                    case 1:
                        modules = _d.sent();
                        _c = modules.map(function (module) { return module.value; }), Search = _c[0], FeatureLayer = _c[1];
                        if (!Search || !FeatureLayer || !Expand_1.default)
                            return [2 /*return*/];
                        group = _getPosition(searchPosition);
                        if (propertyName === "searchPosition" && node) {
                            // move the node if it exists we have to type as any here 
                            // due to a doc issue with move once index is doc'd remove 
                            view.ui.move(node, searchPosition);
                            node.group = group;
                        }
                        else if (propertyName === "searchOpenAtStart" && node) {
                            node.expanded = searchOpenAtStart;
                        }
                        else if (propertyName === "search" || (propertyName === "extentSelector" && node) || (node && propertyName === "extentSelector") || (propertyName === "searchConfiguration" && node)) {
                            if (node)
                                view.ui.remove(node);
                            sources = searchConfiguration === null || searchConfiguration === void 0 ? void 0 : searchConfiguration.sources;
                            if (sources) {
                                extent_1 = null;
                                if (extentSelector) {
                                    geometry = ((_a = extentSelectorConfig === null || extentSelectorConfig === void 0 ? void 0 : extentSelectorConfig.constraints) === null || _a === void 0 ? void 0 : _a.geometry) || null;
                                    if (geometry) {
                                        extent_1 = jsonUtils_1.fromJSON(geometry);
                                    }
                                }
                                sources.forEach(function (source) {
                                    var _a, _b, _c;
                                    var sourceLayer = null;
                                    if ((_a = source === null || source === void 0 ? void 0 : source.layer) === null || _a === void 0 ? void 0 : _a.id)
                                        sourceLayer = view.map.findLayerById(source.layer.id);
                                    if (!sourceLayer && ((_b = source === null || source === void 0 ? void 0 : source.layer) === null || _b === void 0 ? void 0 : _b.url))
                                        sourceLayer = new FeatureLayer.default((_c = source === null || source === void 0 ? void 0 : source.layer) === null || _c === void 0 ? void 0 : _c.url);
                                    source.outFields = ["*"];
                                    source.layer = sourceLayer;
                                    if (extent_1 && ((extent_1 === null || extent_1 === void 0 ? void 0 : extent_1.type) === "extent" || (extent_1 === null || extent_1 === void 0 ? void 0 : extent_1.type) === "polygon")) {
                                        source.filter = {
                                            geometry: extent_1
                                        };
                                    }
                                    else {
                                        source.filter = null;
                                    }
                                });
                            }
                            if (searchConfiguration === undefined || searchConfiguration === null || ((_b = searchConfiguration === null || searchConfiguration === void 0 ? void 0 : searchConfiguration.sources) === null || _b === void 0 ? void 0 : _b.length) === 0) {
                                searchConfiguration = {
                                    includeDefaultSources: true
                                };
                            }
                            content_1 = new Search.default(tslib_1.__assign({ view: view,
                                portal: portal }, searchConfiguration));
                            handle_1 = content_1 === null || content_1 === void 0 ? void 0 : content_1.viewModel.watch('state', function (state) {
                                if (state === 'ready') {
                                    handle_1.remove();
                                    watchUtils_1.whenDefinedOnce(content_1, "allPlaceholder", function () {
                                        content_1.allSources.forEach(function (s) {
                                            if (s.placeholder === "") {
                                                s.placeholder = content_1.allPlaceholder;
                                            }
                                        });
                                    });
                                }
                            });
                            content_1.on("search-complete", function () {
                                if (content_1.popupEnabled) {
                                    // Handle setting focus on popup and then back 
                                    // to search box 
                                    if (popupHover)
                                        view.popup.autoOpenEnabled = true;
                                    watchUtils_1.whenTrueOnce(view.popup.viewModel, "active", function () {
                                        view.popup.focus();
                                        watchUtils_1.whenFalseOnce(view.popup, "visible", function () {
                                            content_1.focus();
                                            if (popupHover)
                                                view.popup.autoOpenEnabled = false;
                                        });
                                    });
                                }
                            });
                            tip = "" + bundle.tools.search;
                            searchExpand = new Expand_1.default({
                                expanded: searchOpenAtStart,
                                id: "searchExpand",
                                content: content_1,
                                collapseTooltip: tip,
                                expandTooltip: tip,
                                group: group,
                                mode: "floating",
                                view: view
                            });
                            view.ui.add(searchExpand, searchPosition);
                            t9nUtils_1.autoUpdatedStrings.add({ obj: searchExpand, property: "expandTooltip", bundleName: bundleName, key: "tools.search" });
                            t9nUtils_1.autoUpdatedStrings.add({ obj: searchExpand, property: "collapseTooltip", bundleName: bundleName, key: "tools.search" });
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    exports.addSearch = addSearch;
    function _getPosition(position) {
        // object or string 
        var groupName = null;
        if (typeof position === "string") {
            groupName = position;
        }
        else if (position === null || position === void 0 ? void 0 : position.position) {
            groupName = position.position;
        }
        // if we are on mobile set group name to mobile so only one is open 
        if (window === null || window === void 0 ? void 0 : window.matchMedia("only screen and (max-width: 480px)").matches) {
            // extract first part of group name
            var corner = groupName === null || groupName === void 0 ? void 0 : groupName.split("-");
            groupName = (corner === null || corner === void 0 ? void 0 : corner.length) > 0 ? "mobile-" + corner[0] : groupName;
        }
        return groupName;
    }
});
