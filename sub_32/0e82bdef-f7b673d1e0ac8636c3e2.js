"use strict";(self.webpackChunknative_apis_doc=self.webpackChunknative_apis_doc||[]).push([[6734],{19752:function(e,a,n){n.d(a,{Z:function(){return c}});var t=n(63366),r=(n(67294),n(63497)),i=n(94701),s=["components"],m=function(e){return function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.mdx)("div",a)}},o=m("If"),p=m("Term"),d=m("Note"),l=m("CodeBlock"),f={_frontmatter:{}};function c(e){var a=e.components,n=(0,t.Z)(e,s);return(0,r.mdx)("wrapper",Object.assign({},f,n,{components:a,mdxType:"MDXLayout"}),(0,r.mdx)(o,{c:n.intro,mdxType:"If"},(0,r.mdx)("p",null,"Your ArcGIS Runtime app can use a ",(0,r.mdx)(p,{term:"web map",mdxType:"Term"},"web map")," while it has no internet connection, by first downloading an ",(0,r.mdx)(p,{term:"offline map",mdxType:"Term"},"offline map")," from the web map. As soon as the offline map is downloaded, a mobile worker can disconnect their device and work with the map offline."),(0,r.mdx)("p",null,"Mobile users can specify a geographic area of a web map to download as an offline map. Offline maps defined and created this way are known as ",(0,r.mdx)("em",{parentName:"p"},"on-demand offline maps"),". On-demand offline maps are useful for mobile users who don't necessarily know in advance where they will be working."),(0,r.mdx)("p",null,"The main advantage of on-demand offline maps is that your app can specify parameters to ensure that only essential web map content is included in the offline map, such as:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The area of interest"),(0,r.mdx)("li",{parentName:"ul"},"The max and min scales"),(0,r.mdx)("li",{parentName:"ul"},"Which layers to include"),(0,r.mdx)("li",{parentName:"ul"},"Which features to include"),(0,r.mdx)("li",{parentName:"ul"},"Which related records to include"),(0,r.mdx)("li",{parentName:"ul"},"Whether to include attachments"),(0,r.mdx)("li",{parentName:"ul"},"Editing characteristics")),(0,r.mdx)("p",null,"The steps to use on-demand offline maps are:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("a",{parentName:"li",href:"#create-an-offline-map-task"},"Create an offline map task")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("a",{parentName:"li",href:"#examine-the-web-maps-offline-capabilities"},"Examine the web map's offline capabilities")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("a",{parentName:"li",href:"#create-parameters-to-specify-offline-map-content"},"Create parameters to specify offline map content")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("a",{parentName:"li",href:"#create-a-job-to-generate-and-download-an-offline-map"},"Create a job to generate and download an offline map")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("a",{parentName:"li",href:"#run-the-job"},"Run the job"))),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",null,"On-demand offline maps are very flexible, but because they require the user to identify the geographic area of interest and content to download from the web map at the time it is needed, the user must wait for the offline map to be generated before it can be downloaded. Also, each user needs to make their own request, possibly for the very same map areas that other users have already downloaded. Contrast this with ahead-of-time offline maps, which are limited to specific areas defined by the web map's owner, but which are generated ahead of time, ready to be downloaded by many different users."),(0,r.mdx)("p",null,"For more information on using the ",(0,r.mdx)(p,{term:"ahead-of-time workflow",mdxType:"Term"},"ahead-of-time workflow"),", see ",(0,r.mdx)("a",{parentName:"p",href:"../download-an-offline-map-ahead-of-time/"},"Download an offline map (ahead of time)"),"."),(0,r.mdx)("p",null,"To learn more about the differences between ahead-of-time and on-demand offline maps, see ",(0,r.mdx)("a",{parentName:"p",href:"/documentation/mapping-apis-and-services/offline/offline-maps/ahead-of-time-vs-on-demand/"},"Preplanned vs on-demand"),".")),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",null,"To take a web map offline on-demand, use ArcGIS Online or ArcGIS Enterprise version 10.3 or later. You must ensure that all services used in the web map are enabled for offline use."))),(0,r.mdx)(o,{c:n.createOfflineMapTask,mdxType:"If"},(0,r.mdx)("p",null,"Create an ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_qt:!0,mdxType:"APITypeMemberNames"}))," from either an online ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{Map_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{Map_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{Map_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{Map_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{Map_qt:!0,mdxType:"APITypeMemberNames"}))," or from a ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{PortalItem_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{PortalItem_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{PortalItem_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{PortalItem_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{PortalItem_qt:!0,mdxType:"APITypeMemberNames"})),"representing a web map."),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},"//Create a task from a map\nself.offlineMapTask = AGSOfflineMapTask(onlineMap: map)\n        \n//or from an online map's portal item\nself.offlineMapTask = AGSOfflineMapTask(portalItem: portalItem)\n"))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"//Create a task from a map\nofflineMapTask = new OfflineMapTask(map);\n\n//or from an online map's portal item\nofflineMapTask = new OfflineMapTask(portalItem);\n"))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"CreateOfflineMapTask",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"//Create a task from a map\nofflineMapTask = new OfflineMapTask(map);\n\n//or from an online map's portal item\nofflineMapTask = new OfflineMapTask(portalItem);\n")))),(0,r.mdx)(o,{c:n.examineWebMapCapabilities,mdxType:"If"},(0,r.mdx)("p",null,"You should check which layers and tables in the web map can be taken offline by examining the web map's offline capabilities. This can help identify layers or tables that are missing in the offline map that is generated."),(0,r.mdx)("p",null,"Get the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapCapabilities_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapCapabilities_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapCapabilities_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapCapabilities_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapCapabilities_qt:!0,mdxType:"APITypeMemberNames"}))," object by calling the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"getOfflineMapCapabilities")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"getOfflineMapCapabilitiesAsync"))," ",(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"getOfflineMapCapabilitiesAsync")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"offlineMapCapabilities")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"GetOfflineMapCapabilitiesAsync"))," method on ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_qt:!0,mdxType:"APITypeMemberNames"})),". "),(0,r.mdx)("p",null,"When ",(0,r.mdx)("inlineCode",{parentName:"p"},"true"),", the ",(0,r.mdx)("inlineCode",{parentName:"p"},"hasErrors")," property indicates that one or more layers or tables cannot be taken offline due to an error. You can check the ",(0,r.mdx)("inlineCode",{parentName:"p"},"layerCapabilities")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"tableCapabilities")," to determine which layer or table cannot be taken offline, and why. "),(0,r.mdx)("p",null,"Some layers do not support being taken offline (either they have not been offline-enabled, or the type of layer does not support being taken offline). An offline map can still include references to these ",(0,r.mdx)("em",{parentName:"p"},"online-only")," layers, allowing the layers to be accessed and displayed whenever a network connection is available. This capability is set by ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AGSOnlineOnlyServicesOption")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"OnlineOnlyServicesOption")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"OnlineOnlyServicesOption")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"OnlineOnlyServicesOption")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"OnlineOnlyServicesOption")),". "),(0,r.mdx)("p",null,"See ",(0,r.mdx)("a",{parentName:"p",href:"/net/offline-maps-scenes-and-data/download-an-offline-map-on-demand/#retain-online-services"},"Retain online services")," for more information."),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},'self.offlineMapTask?.getOfflineMapCapabilities(with: generateParameters, completion: { (capabilities, error) in\n    if let error = error {\n        print(error)\n        return\n    }\n    guard capabilities != nil else {\n        print("No capabilities")\n        return\n    }\n    if let capabilities = capabilities {\n        capabilities.layerCapabilities.forEach {(layerCapability) in\n            if !layerCapability.value.supportsOffline {\n                print((layerCapability.key.name), " Cannot be taken offline")\n            }\n        }\n        capabilities.tableCapabilities.forEach {(tableCapability) in\n            if !tableCapability.value.supportsOffline {\n                print((tableCapability.key.tableName), " Cannot be taken offline")\n            }\n        }\n    }\n})\n'))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"CheckOfflineMapCapabilities",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'final ListenableFuture<OfflineMapCapabilities> offlineMapCapabilitiesFuture =\n    offlineMapTask.getOfflineMapCapabilitiesAsync(generateMapParameters);\nofflineMapCapabilitiesFuture.addDoneListener(new Runnable() {\n  @Override\n  public void run() {\n    try {\n      OfflineMapCapabilities offlineMapCapabilities = offlineMapCapabilitiesFuture.get();\n      if (offlineMapCapabilities.hasErrors()) {\n        // Handle possible errors with layers\n        for (java.util.Map.Entry<Layer, OfflineCapability> layerCapability :\n            offlineMapCapabilities.getLayerCapabilities().entrySet()) {\n          if (!layerCapability.getValue().isSupportsOffline()) {\n            showMessage(layerCapability.getKey().getName() + " cannot be taken offline\\n" +\n                "Error: " + layerCapability.getValue().getError().getMessage());\n          }\n        }\n\n        // Handle possible errors with tables\n        for (java.util.Map.Entry<FeatureTable, OfflineCapability> tableCapability :\n            offlineMapCapabilities.getTableCapabilities().entrySet()) {\n          if (!tableCapability.getValue().isSupportsOffline()) {\n            showMessage(tableCapability.getKey().getTableName() + " cannot be taken offline\\n" +\n                "Error : " + tableCapability.getValue().getError().getMessage());\n          }\n        }\n      } else {\n        // All layers and tables can be taken offline!\n        showMessage("All layers are good to go!");\n      }\n    } catch (Exception e) {\n      dealWithException(e);\n    }\n  }\n\n});\n'))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'final ListenableFuture<OfflineMapCapabilities> offlineMapCapabilitiesFuture =\n    offlineMapTask.getOfflineMapCapabilitiesAsync(generateMapParameters);\nofflineMapCapabilitiesFuture.addDoneListener(new Runnable() {\n  @Override\n  public void run() {\n    try {\n      OfflineMapCapabilities offlineMapCapabilities = offlineMapCapabilitiesFuture.get();\n      if (offlineMapCapabilities.hasErrors()) {\n        // Handle possible errors with layers\n        for (java.util.Map.Entry<Layer, OfflineCapability> layerCapability :\n            offlineMapCapabilities.getLayerCapabilities().entrySet()) {\n          if (!layerCapability.getValue().isSupportsOffline()) {\n            showMessage(layerCapability.getKey().getName() + " cannot be taken offline\\n" +\n                "Error: " + layerCapability.getValue().getError().getMessage());\n          }\n        }\n\n        // Handle possible errors with tables\n        for (java.util.Map.Entry<FeatureTable, OfflineCapability> tableCapability :\n            offlineMapCapabilities.getTableCapabilities().entrySet()) {\n          if (!tableCapability.getValue().isSupportsOffline()) {\n            showMessage(tableCapability.getKey().getTableName() + " cannot be taken offline\\n" +\n                "Error : " + tableCapability.getValue().getError().getMessage());\n          }\n        }\n      } else {\n        // All layers and tables can be taken offline!\n        showMessage("All layers are good to go!");\n      }\n    } catch (Exception e) {\n      dealWithException(e);\n    }\n  }\n\n});\n'))),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",null,"Although this step is optional, you can ensure the map contains the expected layers and tables by checking these capabilities."))),(0,r.mdx)(o,{c:n.createParametersToSpecifyOfflineMapContent,mdxType:"If"},(0,r.mdx)("p",null,"When you generate and download an offline map, it should contain content relevant to the mobile user for the geographic area in which they will be working. Take care not to include more content than needed, because this can impact the time it takes to generate and download the offline map. Different parameters are available to control the geographic coverage area and the content of the generated offline map."),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"Create the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," by passing an area of interest to the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"defaultGenerateOfflineMapParameters")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"createDefaultGenerateOfflineMapParametersAsync")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"createDefaultGenerateOfflineMapParametersAsync")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"createDefaultGenerateOfflineMapParameters")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"CreateDefaultGenerateOfflineMapParametersAsync"))," method on the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_qt:!0,mdxType:"APITypeMemberNames"})),".")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"Get and examine the returned parameters. These default parameters represent the advanced offline settings configured by the web map author.")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"To override default parameters see ",(0,r.mdx)("a",{parentName:"p",href:"#advanced-parameters"},"Advanced parameters"),". For example, you can automatically update and display online-only layers when a network connection is available (see ",(0,r.mdx)("a",{parentName:"p",href:"#retain-online-services"},"Retain online services"),"). You can also set the max and min scale, use a local basemap, or set a definition expression on features. "))),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},'offlineMapTask?.defaultGenerateOfflineMapParameters(withAreaOfInterest: geometry, completion: {[weak self] (parameters, error) in\n    if let error = error {\n        print(error)\n        return\n    }\n    guard parameters != nil else {\n        print("No parameters")\n        return\n    }\n    if let parameters = parameters {\n        // Update any of these parameters values, if needed\n        parameters.maxScale = 5000\n        parameters.minScale = 10000\n        parameters.includeBasemap = true\n        parameters.referenceBasemapDirectory = "\\mytilepackages"\n        parameters.referenceBasemapFilename = "mytilepackage.tpkx"\n        parameters.isDefinitionExpressionFilterEnabled = true\n        parameters.continueOnErrors = true\n        parameters.returnSchemaOnlyForEditableLayers = true\n        parameters.attachmentSyncDirection = .upload\n        parameters.returnLayerAttachmentOption = .editableLayers\n        \n        // Update the ItemInfo parameter if you want to change any of the information from the Portal...\n        if let title = parameters.itemInfo?.title.appending(" (Central)") {\n            parameters.itemInfo?.title = title\n        }\n        self?.generateParameters = parameters\n    }\n})\n'))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"SetOfflineMapParameters",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'// generate the default offline map parameters\nListenableFuture<GenerateOfflineMapParameters> parametersListenableFuture =\n  offlineMapTask.createDefaultGenerateOfflineMapParametersAsync(downloadArea);\n\n// listen in for the completion\nparametersListenableFuture.addDoneListener(()-> {\n  // try to get the parameters\n  try {\n    GenerateOfflineMapParameters offlineMapParameters = parametersListenableFuture.get();\n\n    // Update any of these parameters values, if needed\n    offlineMapParameters.setMaxScale(5000);\n    offlineMapParameters.setMinScale(10000);\n    offlineMapParameters.setIncludeBasemap(true);\n    offlineMapParameters.setDefinitionExpressionFilterEnabled(true);\n    offlineMapParameters.setContinueOnErrors(true);\n    offlineMapParameters.setReturnSchemaOnlyForEditableLayers(true);\n    offlineMapParameters.setAttachmentSyncDirection(\n      GenerateGeodatabaseParameters.AttachmentSyncDirection.UPLOAD);\n    offlineMapParameters.setReturnLayerAttachmentOption(\n      GenerateOfflineMapParameters.ReturnLayerAttachmentOption.EDITABLE_LAYERS);\n\n    // Update the ItemInfo parameter if you want to change any of the information from the Portal...\n    String title = offlineMapParameters.getItemInfo().getTitle() + " (Central)";\n    offlineMapParameters.getItemInfo().setTitle(title);\n\n  } catch (Exception e) {\n    dealWithException(e);\n  }\n});\n'))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'// generate the default offline map parameters\nListenableFuture<GenerateOfflineMapParameters> parametersListenableFuture =\n  offlineMapTask.createDefaultGenerateOfflineMapParametersAsync(downloadArea);\n\n// listen in for the completion\nparametersListenableFuture.addDoneListener(()-> {\n  // try to get the parameters\n  try {\n    GenerateOfflineMapParameters offlineMapParameters = parametersListenableFuture.get();\n\n    // Update any of these parameters values, if needed\n    offlineMapParameters.setMaxScale(5000);\n    offlineMapParameters.setMinScale(10000);\n    offlineMapParameters.setIncludeBasemap(true);\n    offlineMapParameters.setDefinitionExpressionFilterEnabled(true);\n    offlineMapParameters.setContinueOnErrors(true);\n    offlineMapParameters.setReturnSchemaOnlyForEditableLayers(true);\n    offlineMapParameters.setAttachmentSyncDirection(\n      GenerateGeodatabaseParameters.AttachmentSyncDirection.UPLOAD);\n    offlineMapParameters.setReturnLayerAttachmentOption(\n      GenerateOfflineMapParameters.ReturnLayerAttachmentOption.EDITABLE_LAYERS);\n\n    // Update the ItemInfo parameter if you want to change any of the information from the Portal...\n    String title = offlineMapParameters.getItemInfo().getTitle() + " (Central)";\n    offlineMapParameters.getItemInfo().setTitle(title);\n\n  } catch (Exception e) {\n    dealWithException(e);\n  }\n});\n'))),(0,r.mdx)(o,{c:"sdk =='qt'",mdxType:"If"},(0,r.mdx)("p",null,"Start by creating the task."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// Create the task\nm_offlineMapTask = new OfflineMapTask(m_map, this);\n")),(0,r.mdx)("p",null,"Then, generate the default parameters for the task."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// After the task loads, get the default parameters.\nconnect(m_offlineMapTask, &OfflineMapTask::doneLoading, this,\n        [this]()\n{\n    Geometry extent = m_map->initialViewpoint().targetGeometry();\n    m_offlineMapTask->createDefaultGenerateOfflineMapParameters(extent);\n});\n")),(0,r.mdx)("p",null,"Set some of the parameters to values that you want for your offline map. Then, see if the map can be taken offline."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'// After getting the default parameters...\nconnect(m_offlineMapTask, &OfflineMapTask::createDefaultGenerateOfflineMapParametersCompleted, this,\n        [this] (QUuid, const GenerateOfflineMapParameters& parameters)\n{\n    // Change parameters as needed by your app.\n    GenerateOfflineMapParameters params = parameters;\n\n\n    params.setMaxScale(5000.0);\n    params.setAttachmentSyncDirection(AttachmentSyncDirection::Upload);\n    params.setReturnLayerAttachmentOption(ReturnLayerAttachmentOption::EditableLayers);\n    params.setReturnSchemaOnlyForEditableLayers(true);\n    params.itemInfo().setTitle(params.itemInfo().title() + " (Central");\n\n\n    qDebug() << "Checking whether map with these parameters can be taken offline...";\n    m_offlineMapTask->offlineMapCapabilities(params);\n});\n\n// Can this map be taken offline?\nconnect(m_offlineMapTask, &OfflineMapTask::offlineMapCapabilitiesCompleted, this,\n        [this] (QUuid, const OfflineMapCapabilities& capabilities)\n{\n    if (!capabilities.hasErrors())\n        qDebug() << "This map may be taken offline.";\n    else\n        qDebug() << "This map may NOT be taken offline.";\n});\n'))),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",null,"Rather than getting the default set of ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"})),", you can construct them manually. A web map author can recommend how data is downloaded and updated by offline clients, by adjusting the map's advanced offline settings. You can access these advanced settings from the map's offline settings. They provide options for:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"working with feature attachments"),(0,r.mdx)("li",{parentName:"ul"},"synchronizing edits"),(0,r.mdx)("li",{parentName:"ul"},"downloading a basemap or using one that is already on the device")),(0,r.mdx)("p",null,"To learn more about configuring the web map's advanced offline settings, see ",(0,r.mdx)("a",{parentName:"p",href:"https://doc.arcgis.com/en/arcgis-online/manage-data/take-maps-offline.htm#esri_section1_6ce94b6639c44d5ab860fd74256387ca"},"Take web maps offline")," in the ArcGIS Online documentation."))),(0,r.mdx)(o,{c:n.createAJobToGenerateAndDownloadAnOfflineMap,mdxType:"If"},(0,r.mdx)("p",null,"To generate and download the offline map, you must create a ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_qt:!0,mdxType:"APITypeMemberNames"}))," by providing the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," to the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMapJobWithParameters:downloadDirectory")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMap")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMap")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMap")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"GenerateOfflineMap"))," method on ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_qt:!0,mdxType:"APITypeMemberNames"})),". You must provide a directory on the device to store the offline map. If this download directory already exists, it must be empty. If the directory doesn't exist, it will be created by the job."),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},"//create the job\nself.generateOfflineMapJob = self.offlineMapTask?.generateOfflineMapJob(\n    with: self.generateParameters,\n    downloadDirectory: URL(string: fullPath)!\n)\n"))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"GenerateOfflineMapJob",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"// create the job\nofflineMapJob = offlineMapTask.generateOfflineMap(offlineMapParameters, downloadDir);\n"))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"// create the job\nofflineMapJob = offlineMapTask.generateOfflineMap(offlineMapParameters, downloadDir);\n"))),(0,r.mdx)("p",null,"If you want to control the individual layer and table content, you also need to provide the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_qt:!0,mdxType:"APITypeMemberNames"}))," as well as the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"})),"to the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMap")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"GenerateOfflineMap")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMap")," result "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMap")," result "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMap")," ")," method on ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_qt:!0,mdxType:"APITypeMemberNames"})),". For more details see ",(0,r.mdx)("a",{parentName:"p",href:"#create-offline-map-parameter-overrides"},"Create offline map parameter overrides"),"."),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},"//create the job\nself.generateOfflineMapJob = self.offlineMapTask?.generateOfflineMapJob(\n    with: self.generateParameters,\n    parameterOverrides: self.generateParameterOverrides,\n    downloadDirectory: URL(string: fullPath)!\n)\n"))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"GenerateOfflineMapJobWithOverrides",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"// create the job\nofflineMapJob = offlineMapTask.generateOfflineMap(offlineMapParameters, downloadDir, overrides);\n"))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"// create the job\nofflineMapJob = offlineMapTask.generateOfflineMap(offlineMapParameters, downloadDir, overrides);\n"))),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",null,"The job will behave the same whether it was created using just the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," or using both the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_qt:!0,mdxType:"APITypeMemberNames"}))," along with the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"})),". Not all layers need to be offline enabled; the job can also reference online layers.")),(0,r.mdx)("p",null,"See the ",(0,r.mdx)("a",{parentName:"p",href:"../../programming-patterns/tasks-and-jobs/"},"Tasks and jobs")," topic for more details on how to work with jobs in general.")),(0,r.mdx)(o,{c:n.RunTheJob,mdxType:"If"},(0,r.mdx)("p",null,"To generate the offline map and download it to your device, start the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_qt:!0,mdxType:"APITypeMemberNames"})),". When complete, the job returns a ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapResult_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapResult_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapResult_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapResult_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapResult_qt:!0,mdxType:"APITypeMemberNames"})),".\nIf one or more tables or layers fails to be taken offline, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"hasErrors"),' property may be true (however a layer may be configured for "online-only", which is not an error). You can check the ',(0,r.mdx)("inlineCode",{parentName:"p"},"layerErrors")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"tableErrors")," dictionaries to identify problems."),(0,r.mdx)("p",null,"If the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"continueOnErrors")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ContinueOnErrors")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ContinueOnErrors")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ContinueOnErrors")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"isContinueOnErrors"))," property of ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"false"),", the job terminates if any layer or table fails to be taken offline."),(0,r.mdx)("p",null,"If you want to display the map immediately, pass the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapResult_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapResult_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapResult_qt:!0,mdxType:"APITypeMemberNames"}))," ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"offlineMap")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"OfflineMap")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"GenerateOfflineMapResult.offlineMapGenerateOfflineMapResult.getOfflineMap")," result "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"GenerateOfflineMapResult.offlineMapGenerateOfflineMapResult.getOfflineMap")," result "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"offlineMap")," ")," to the map view."),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},'//start the job\nself.generateOfflineMapJob.start(statusHandler: {[weak self] (status) in\n    print("Status [\\(String(describing: self?.generateOfflineMapJob.progress.fractionCompleted))]: \\(status)")\n}, completion: { (result, error) in\n    if let error = error {\n        print(error)\n        return\n    }\n    guard let result = result as? AGSGenerateOfflineMapResult else {return}\n    if result.hasErrors {\n        result.layerErrors.forEach{(layerError) in\n            print((layerError.key.name), " Error taking this layer offline")\n        }\n        result.tableErrors.forEach{(tableError) in\n            print((tableError.key.tableName), " Error taking this table offline")\n        }\n    }\n    else {\n        //display the offline map\n        self.mapView.map = result.offlineMap\n    }\n})\n'))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"GetOfflineMapResult",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"//start the job\nofflineMapJob.start();\n\n// listen for the job complete event\nofflineMapJob.addJobDoneListener(() -> {\n  // did the job succeed?\n  if (offlineMapJob.getStatus() == Job.Status.SUCCEEDED) {\n      GenerateOfflineMapResult offlineMapResult = offlineMapJob.getResult();\n\n    // were there any errors?\n    if (offlineMapResult.hasErrors()) {\n      // get the layer errors\n      Map<Layer, ArcGISRuntimeException> layerErrors = offlineMapResult.getLayerErrors();\n\n      // get the table errors\n      Map<FeatureTable, ArcGISRuntimeException> tableErrors = offlineMapResult.getTableErrors();\n\n    } else {\n      // get the offline map which can be used straight away\n      ArcGISMap offlineMap = offlineMapResult.getOfflineMap();\n    }\n\n  } else {\n    // code here to deal with failure\n  }\n});\n"))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"//start the job\nofflineMapJob.start();\n\n// listen for the job complete event\nofflineMapJob.addJobDoneListener(() -> {\n  // did the job succeed?\n  if (offlineMapJob.getStatus() == Job.Status.SUCCEEDED) {\n      GenerateOfflineMapResult offlineMapResult = offlineMapJob.getResult();\n\n    // were there any errors?\n    if (offlineMapResult.hasErrors()) {\n      // get the layer errors\n      Map<Layer, ArcGISRuntimeException> layerErrors = offlineMapResult.getLayerErrors();\n\n      // get the table errors\n      Map<FeatureTable, ArcGISRuntimeException> tableErrors = offlineMapResult.getTableErrors();\n\n    } else {\n      // get the offline map which can be used straight away\n      ArcGISMap offlineMap = offlineMapResult.getOfflineMap();\n    }\n\n  } else {\n    // code here to deal with failure\n  }\n});\n"))),(0,r.mdx)("p",null,"Offline maps created by the on-demand workflow are stored in an unpacked mobile map package. When your app goes into the field, you need to open the map directly from this mobile map package ",(0,r.mdx)("inlineCode",{parentName:"p"},"downloadDirectory")," stored on your device.")),(0,r.mdx)(o,{c:n.AdvancedParameters,mdxType:"If"},(0,r.mdx)("p",null,"You can set properties on ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," to control the offline map content. For example:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The map's ",(0,r.mdx)("a",{parentName:"li",href:"#scale-range"},"max and min scale")),(0,r.mdx)("li",{parentName:"ul"},"Whether ",(0,r.mdx)("a",{parentName:"li",href:"#include-a-maps-basemap"},"basemaps are included in the map")),(0,r.mdx)("li",{parentName:"ul"},"Whether layers that reference ",(0,r.mdx)("a",{parentName:"li",href:"#retain-online-services"},"online services are retained")," in the map"),(0,r.mdx)("li",{parentName:"ul"},"Whether to ",(0,r.mdx)("a",{parentName:"li",href:"#manage-synchronization-of-the-maps-geodatabases"},"allow synchronization of the map's geodatabases")),(0,r.mdx)("li",{parentName:"ul"},"Whether to ",(0,r.mdx)("a",{parentName:"li",href:"#apply-feature-layer-definition-expression-filters"},"apply definition expression filters")),(0,r.mdx)("li",{parentName:"ul"},"Whether to ",(0,r.mdx)("a",{parentName:"li",href:"#return-all-rows-from-a-related-table"},"return all rows from a related table")),(0,r.mdx)("li",{parentName:"ul"},"Whether to ",(0,r.mdx)("a",{parentName:"li",href:"#continue-downloading-the-map-if-a-single-layer-or-table-fails"},"continue downloading the map if a single layer fails to be taken offline")," "),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("a",{parentName:"li",href:"#inclusion-of-feature-attachments"},"Including feature attachments")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("a",{parentName:"li",href:"#inclusion-of-features-from-editable-feature-layers"},"Whether only the schema is provided for editable feature layers")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("a",{parentName:"li",href:"#update-or-replace-the-maps-metadata"},"Update or replace the map's metadata"))),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",null,"If you need fine control over how individual layers from the web map are included in the offline map, you can use overrides. See ",(0,r.mdx)("a",{parentName:"p",href:"#create-offline-map-parameter-overrides"},"Create offline map parameter overrides"),"."))),(0,r.mdx)(o,{c:n.ScaleRange,mdxType:"If"},(0,r.mdx)("p",null,"A web map might include image tiled layers, which are composed of many tiles at different levels of detail (similar to a “zoom level”). The amount of space, generation time, and download time required to download tiled layers in a web map will increase with every level of detail. To increase performance, you should only download the levels of detail that are relevant for your app. You can control this by setting the minimum and maximum scale parameters ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"minScale")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"maxScale")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"MinScale")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"MaxScale")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"minScale")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"maxScale")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"minScale")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"maxScale")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"maxScale")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"minScale")),"."),(0,r.mdx)("p",null,"If possible, choose a maximum scale that is not too “zoomed in” to prevent generating a large number of unnecessary tiles. Each service limits the number of tiles that can be taken offline. Make sure to set a scale range that avoids hitting this limit."),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",null,"An on-demand workflow honors the scale range of a tiled layer specified by the web map. This ensures that only tile data required by the offline map is downloaded."),(0,r.mdx)("p",null,"For example, if the web map contains a tiled layer that is set to a min scale of 1:1,000,000 and a max scale of 1:10,000, these values are applied to the scale range requested by the user. If a user requests data for a scale range of 1:900,000 to 1:5,000, the minimum range of 1:900,000 (min scale defined in the user's parameters) to 1:10,000 (max scale defined on the web map) is downloaded. If the user requests the default scale values of 1:0, the range from the web map is applied."))),(0,r.mdx)(o,{c:n.includeAMapsBasemap,mdxType:"If"},(0,r.mdx)("p",null,"A web map author can define whether offline maps should:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Download the basemap defined by the web map. This is the default and ensures that a tile package is downloaded with the map.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Use a tile package that is already on the device. The tile package must be downloaded or copied onto the device separately and can be referenced with an absolute file path or a path relative to the map. Make sure the tile package covers the areas required by your map area. The benefits of this option are that the map file will be smaller, the download time may be faster, and you can use the tile package in many different maps and apps."),(0,r.mdx)("p",{parentName:"li"}," To use the tile package on your device, you must set the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," ",(0,r.mdx)("inlineCode",{parentName:"p"},"referenceBasemapDirectory")," to the directory that contains the tile package. You should confirm that the tile package file, ",(0,r.mdx)("inlineCode",{parentName:"p"},"referenceBasemapFilename"),", exists on the device before running the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_qt:!0,mdxType:"APITypeMemberNames"})),". This job will add the tile package, as a basemap, to the offline map."),(0,r.mdx)(d,{mdxType:"Note"},"If this tile package has a different spatial reference than your online map, the offline map will use the spatial reference of the tile package.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Avoid using the basemap. Developers can choose to override this configured behavior when they download an offline map from a web map. To do this, set the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"includeBasemap")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"includeBasemap")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"isIncludeBasemap")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"isIncludeBasemap")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"includeBasemap"))," property to ",(0,r.mdx)("inlineCode",{parentName:"p"},"false"),". In this case the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_qt:!0,mdxType:"APITypeMemberNames"}))," will not download any layers included as part of the map's ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{Basemap_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{Basemap_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{Basemap_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{Basemap_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{Basemap_qt:!0,mdxType:"APITypeMemberNames"})),". This task will not use the local tile package, even if you have specified one.")))),(0,r.mdx)(o,{c:n.retainOnlineServices,mdxType:"If"},(0,r.mdx)("p",null,"Live, online services are supported in offline maps. You can take a web map offline that has a mix of local on-device content as well as live, online service content (such as weather or traffic information). When network connectivity is available, users can use data from online services. Otherwise, only the local (offline) content is available."),(0,r.mdx)("p",null,"A value of ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"include")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"Include")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"INCLUDE")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"Include")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"Include"))," for ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"onlineOnlyServicesOption")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"OnlineOnlyServicesOption")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"OnlineOnlyServicesOption")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"OnlineOnlyServicesOption")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"onlineOnlyServicesOption"))," means that any data that can't be taken offline will be accessed via the URL in the offline map. Your offline map retains all of the information from the original web map, but requires a network connection and may require authentication."),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",null,"In some situations, you may wish to prevent a layer from being taken offline even though it is supported. For example, by continuing to reference the live online service you can benefit from the most up-to-date information. You can choose to keep layers online from the map's operational layers or basemap layers collections, as well as individual non-spatial tables. To learn more, see ",(0,r.mdx)("a",{parentName:"p",href:"#create-offline-map-parameter-overrides"},"Create offline map parameter overrides"),"."))),(0,r.mdx)(o,{c:n.manageSynchronizationOfTheMapsGeodatabases,mdxType:"If"},(0,r.mdx)("p",null,"Typically, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateMode"),"on the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," is set to ",(0,r.mdx)("inlineCode",{parentName:"p"},"syncWithFeatureServices"),". This mode allows you to synchronize any geodatabase changes with their online feature services."),(0,r.mdx)("p",null,"If you want to avoid receiving any geodatabase updates, set the ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateMode")," on the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," to ",(0,r.mdx)("inlineCode",{parentName:"p"},"noUpdates"),". This disables data synchronization on the map’s geodatabases and prevents the corresponding feature services from creating synchronization replicas. The benefits of this option are that the burden on the feature server is reduced and you will not need to unregister geodatabases when they are no longer required.")),(0,r.mdx)(o,{c:n.applyFeatureLayerDefinitionExpressionFilters,mdxType:"If"},(0,r.mdx)("p",null,"When taking a map offline, the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_qt:!0,mdxType:"APITypeMemberNames"}))," applies the feature layer's definition expression by default. Applying the definition expression may reduce the number of features taken offline for display and sync. If you do not want to apply the definition expression, set ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"IsDefinitionExpressionFilterEnabled")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"IsDefinitionExpressionFilterEnabled")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"isDefinitionExpressionFilterEnabled")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"IsDefinitionExpressionFilterEnabled")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"isDefinitionExpressionFilterEnabled"))," to ",(0,r.mdx)("inlineCode",{parentName:"p"},"false"),".")),(0,r.mdx)(o,{c:n.returnAllRowsFromARelatedTable,mdxType:"If"},(0,r.mdx)("p",null,"If a map contains a layer or table with a relationship to another table, you can choose to download all rows or only related rows from the destination table. The default is to download only the related rows. If you want to return all rows, then you must set the value of ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_DestinationTableRowFilter_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_DestinationTableRowFilter_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_DestinationTableRowFilter_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_DestinationTableRowFilter_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_DestinationTableRowFilter_qt:!0,mdxType:"APITypeMemberNames"})),"\nto be ",(0,r.mdx)("inlineCode",{parentName:"p"},"All"),"."),(0,r.mdx)("p",null,"If the table is a standalone table or the source of a relationship, all rows are returned.")),(0,r.mdx)(o,{c:n.continueDownloadingTheMapIfASingleLayerOrTableFails,mdxType:"If"},(0,r.mdx)("p",null,"By default, the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_qt:!0,mdxType:"APITypeMemberNames"}))," continues to take layers and tables offline even if a layer or table fails. While this ensures that the map is taken offline, data may be missing. When the job completes, you should examine the job's result (discussed under ",(0,r.mdx)("a",{parentName:"p",href:"#run-the-job"},"Run the job"),") to identify if any layers have failed and determine whether or not to continue working with the map."),(0,r.mdx)("p",null,"If you want the job to stop immediately when a layer or table fails, set the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)("inlineCode",{parentName:"p"},"ContinueOnErrors")," property to ",(0,r.mdx)("inlineCode",{parentName:"p"},"false"),". This ensures that if a map is successfully taken offline it contains all of its layers and tables. "),(0,r.mdx)("p",null,"Failure to take a layer or table offline may be due to an intermittent network connection, loss of the service, or an unsupported layer type.")),(0,r.mdx)(o,{c:n.inclusionOfFeatureAttachments,mdxType:"If"},(0,r.mdx)("p",null,"Some feature services contain attachments (pictures, videos, and other documents) for individual features. Because these files can be large, you should consider your app's offline workflow to determine whether the attachments need to be taken offline, and whether they need to be synchronized with the service when the app is connected. These two behaviors are defined using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection")," properties on the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," class."),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"The return layer attachment property defines which layers should contain attachments in the offline map. The options are:"),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.none")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption.None")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.NONE")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.NONE")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption::None"))," - None of the layers contain attachments.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.allLayers")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption.AllLayers")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.ALL_LAYERS")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.ALL_LAYERS")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption::AllLayers"))," - All layers have their attachments.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.readOnlyLayers")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption.ReadOnlyLayers")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.READ_ONLY_LAYERS")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.READ_ONLY_LAYERS")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption::ReadOnlyLayers"))," - Layers without editing enabled have attachments.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.editableLayers")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption.EditableLayers")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.EDITABLE_LAYERS")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.EDITABLE_LAYERS")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption::EditableLayers"))," - Layers with editing enabled have attachments.")))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"The attachment sync direction defines how the attachments are synchronized with the service. The options are:"),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.none")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection.None")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.NONE")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.NONE")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection::None"))," - Attachments are not synchronized as part of the synchronization operation.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.upload")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection.Upload")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.UPLOAD")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.UPLOAD")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection::Upload"))," - Attachments are uploaded from the client to the service, but any changes on the service are not downloaded to the client.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.bidirectional")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection.Bidirectional")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.BIDIRECTIONAL")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.BIDIRECTIONAL")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection::Bidirectional"))," - Attachments are uploaded from client to the service, and changes on the service are pulled down to the client."),(0,r.mdx)(d,{mdxType:"Note"},(0,r.mdx)("p",{parentName:"li"},"Attachment sync direction was introduced with ArcGIS Server 10.4."))))))),(0,r.mdx)(o,{c:n.inclusionOfFeaturesFromEditableFeatureLayers,mdxType:"If"},(0,r.mdx)("p",null,"Here are some workflows that describe how these two parameters affect each other:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Workflow 1 — Download attachments for all layers in the map, allow the user to add or remove attachments from the layers, and then synchronize these changes between the service and the client when online. For example: multiple users collect data on the same area and they want to synchronize all the changes with the centralized services as well as sharing changes with other people in the field."),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.allLayers")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption.AllLayers")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.ALL_LAYERS")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.ALL_LAYERS")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption::AllLayers")))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.bidirectional")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection.Bidirectional")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.BIDIRECTIONAL")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.BIDIRECTIONAL")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection::Bidirectional")))))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Workflow 2 — Download attachments for all read-only layers and update these layers when online. For example: users are offline and viewing a layer of buildings with photos that show how the buildings look. If there are any new photos added to the service, these will be downloaded to the client during synchronization when online."),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.readOnlyLayers")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption.ReadOnlyLayers")),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.READ_ONLY_LAYERS")),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.READ_ONLY_LAYERS")),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption::ReadOnlyLayers")))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.bidirectional")),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection.Bidirectional")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.BIDIRECTIONAL")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.BIDIRECTIONAL")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection::Bidirectional")))))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Workflow 3 — Download attachments for editable layers only and upload them to the service when online. For example: users are offline and only need to view attachments for editable layers. If there are any read-only layers that provide context for the map, their attachments aren’t included to the local map. If users remove or add any new attachments, these changes can be synchronized to the service when online."),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.editableLayers")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption.EditableLayers")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.EDITABLE_LAYERS")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.EDITABLE_LAYERS")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption::EditableLayers")))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.bidirectional")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection.Bidirectional")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.BIDIRECTIONAL")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.BIDIRECTIONAL")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection::Bidirectional")," "))))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Workflow 4 — Do not download any attachments but allow any new attachments to be uploaded to the service when online. For example: users are offline and collecting new attachments in the field but do not need to view existing attachments."),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.none")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption.None")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.NONE")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnLayerAttachmentOption.NONE")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnLayerAttachmentOption::None")," "))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.upload")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection.Upload")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.UPLOAD")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"attachmentSyncDirection.UPLOAD")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"AttachmentSyncDirection::Upload")," ")))))),(0,r.mdx)("p",null,"If users are collecting new information in the field where they do not need to access previously created features, you can create an offline map with empty editable feature layers. Do this by setting the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," property ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"returnSchemaOnlyForEditableLayerss")," "),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnSchemaOnlyForEditableLayers")," "),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"setReturnSchemaOnlyForEditableLayers")," "),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"setReturnSchemaOnlyForEditableLayers")," "),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)("inlineCode",{parentName:"p"},"setReturnSchemaOnlyForEditableLayers")," ")," to ",(0,r.mdx)("inlineCode",{parentName:"p"},"True"),".")),(0,r.mdx)(o,{c:n.updateOrReplacetheMapsMetadata,mdxType:"If"},(0,r.mdx)("p",null,"Access an online map's metadata from the ",(0,r.mdx)("inlineCode",{parentName:"p"},"itemInfo")," property. It includes portal item properties such as the title, description, short description, and thumbnail. This information is populated from the portal item that contains the map. You can override any of these metadata properties before you take the map offline. For example, if you are creating offline maps of different areas of interest on the same map, you may want to change the map's title to indicate which area it contains."),(0,r.mdx)("p",null,"You can also create a new ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapItemInfo_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapItemInfo_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapItemInfo_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapItemInfo_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapItemInfo_qt:!0,mdxType:"APITypeMemberNames"}))," object and manually set all the details."),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},'// Create new item info\nlet itemInfo = AGSOfflineMapItemInfo()\n                \n// Set metadata on the itemInfo\nitemInfo.title = "Water network (Central)"\nitemInfo.tags.append("Water network")\nitemInfo.tags.append("Data validation")\nitemInfo.thumbnail = thumbnail\n\nparameters.itemInfo = itemInfo\n'))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"CreateOfflineMapItemInfo",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'// Create new item info\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Set metadata on the itemInfo\nitemInfo.setTitle("Water network (Central)");\nitemInfo.getTags().add("Water network");\nitemInfo.getTags().add("Data validation");\nitemInfo.setThumbnailData(thumbnail);\n\nofflineMapParameters.setItemInfo(itemInfo);\n'))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'// Create new item info\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Set metadata on the itemInfo\nitemInfo.setTitle("Water network (Central)");\nitemInfo.getTags().add("Water network");\nitemInfo.getTags().add("Data validation");\nitemInfo.setThumbnailData(thumbnail);\n\nofflineMapParameters.setItemInfo(itemInfo);\n')))),(0,r.mdx)(o,{c:n.createOfflineMapParameterOverrides,mdxType:"If"},(0,r.mdx)("p",null,"You may want to control how individual layers or tables are taken offline to do things like:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Reduce the amount of data (for example, tile data) for a given layer"),(0,r.mdx)("li",{parentName:"ul"},"Alter the spatial extent of a given layer (for example, to give coverage beyond the study area)"),(0,r.mdx)("li",{parentName:"ul"},"Filter features (for example, with a where clause) to only take those that are relevant to your fieldwork"),(0,r.mdx)("li",{parentName:"ul"},"Take features with null geometry (for example, where the attributes are populated in the office but the geometry needs to be captured on-site)"),(0,r.mdx)("li",{parentName:"ul"},"Omit individual layers"),(0,r.mdx)("li",{parentName:"ul"},"Define which layers should reference online content")),(0,r.mdx)("p",null,"The ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_qt:!0,mdxType:"APITypeMemberNames"}))," object provides control for these behaviors. It includes three dictionaries containing the generate geodatabase parameters (for ",(0,r.mdx)(p,{term:"feature layer",mdxType:"Term"},"feature layers"),"), export vector tile parameters (for ",(0,r.mdx)(p,{term:"vector tile layer",mdxType:"Term"},"vector tile layers"),"), and export tile cache parameters (for ",(0,r.mdx)(p,{term:"image tile layer",mdxType:"Term"},"image tile layers"),"), as well as two lists of layers and tables that will retain online access in the offline map (see ",(0,r.mdx)("a",{parentName:"p",href:"#retain-online-services"},"Retain online services"),"). Adjust any of these parameters and create the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_qt:!0,mdxType:"APITypeMemberNames"}))," using the overrides object."),(0,r.mdx)("p",null,"To control how individual layers and tables are taken offline, follow these steps:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"Generate and modify the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," as described in ",(0,r.mdx)("a",{parentName:"p",href:"#create-parameters-to-specify-offline-map-content"},"Create parameters to specify offline map content")," above.")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"Generate the parameter overrides object (",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_qt:!0,mdxType:"APITypeMemberNames"})),") using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"generateOfflineMapParameterOverrides")," method on the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_qt:!0,mdxType:"APITypeMemberNames"})),". Provide the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"})),"\ngenerated from the previous step.")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"When the task completes, a pre-populated ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_qt:!0,mdxType:"APITypeMemberNames"}))," object will be provided. This is a modifiable layer-by-layer representation of the supplied ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_qt:!0,mdxType:"APITypeMemberNames"}))," and includes three dictonaries containing detailed parameters for each layer and table:"),(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateGeodatabaseParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateGeodatabaseParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateGeodatabaseParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateGeodatabaseParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateGeodatabaseParameters_qt:!0,mdxType:"APITypeMemberNames"}))," for ",(0,r.mdx)(p,{term:"feature layer",mdxType:"Term"},"feature layers"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportVectorTilesParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportVectorTilesParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportVectorTilesParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportVectorTilesParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportVectorTilesParameters_qt:!0,mdxType:"APITypeMemberNames"}))," for ",(0,r.mdx)(p,{term:"vector tile layer",mdxType:"Term"},"vector tile layers"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportTileCacheParameters_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportTileCacheParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportTileCacheParameters_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportTileCacheParameters_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{ExportTileCacheParameters_qt:!0,mdxType:"APITypeMemberNames"}))," for ",(0,r.mdx)(p,{term:"image tile layer",mdxType:"Term"},"image tile layers"),".")),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},'offlineMapTask?.generateOfflineMapParameterOverrides(with: self.generateParameters, completion: {[weak self](parameterOverrides, error) in\n    if let error = error {\n        print(error)\n        return\n    }\n    guard parameterOverrides != nil else {\n        print("No parameter Overrides")\n        return\n    }\n    if let parameterOverrides = parameterOverrides {\n        var exportTileCacheParameters = parameterOverrides.exportTileCacheParameters\n        var exportVectorTilesParameters = parameterOverrides.exportVectorTilesParameters\n        var generateGeodatabaseParameters = parameterOverrides.generateGeodatabaseParameters\n        //adjust these parameters as required\n        //retain the overrides outside the completion block\n        self?.generateParameterOverrides = parameterOverrides\n    }\n})\n'))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"GdbParamOverride",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"// generate the offline map parameter overrides\nListenableFuture<GenerateOfflineMapParameterOverrides> overridesListener =\n  offlineMapTask.createGenerateOfflineMapParameterOverridesAsync(offlineMapParameters);\n\n// listen for the completion\noverridesListener.addDoneListener(()-> {\n  // try to get them\n  try {\n    GenerateOfflineMapParameterOverrides overrides = overridesListener.get();\n    Map<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParams =\n      overrides.getExportTileCacheParameters();\n    Map<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParams =\n      overrides.getExportVectorTilesParameters();\n    Map<OfflineMapParametersKey, GenerateGeodatabaseParameters> gdbParams =\n      overrides.getGenerateGeodatabaseParameters();\n  } catch (Exception e) {\n    dealWithException(e);\n  }\n});\n"))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"// generate the offline map parameter overrides\nListenableFuture<GenerateOfflineMapParameterOverrides> overridesListener =\n  offlineMapTask.createGenerateOfflineMapParameterOverridesAsync(offlineMapParameters);\n\n// listen for the completion\noverridesListener.addDoneListener(()-> {\n  // try to get them\n  try {\n    GenerateOfflineMapParameterOverrides overrides = overridesListener.get();\n    Map<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParams =\n      overrides.getExportTileCacheParameters();\n    Map<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParams =\n      overrides.getExportVectorTilesParameters();\n    Map<OfflineMapParametersKey, GenerateGeodatabaseParameters> gdbParams =\n      overrides.getGenerateGeodatabaseParameters();\n  } catch (Exception e) {\n    dealWithException(e);\n  }\n});\n"))),(0,r.mdx)("p",{parentName:"li"},"To override specific parameters for a layer, create a ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapParametersKey_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameters_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapParametersKey_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParametersKey_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParametersKey_qt:!0,mdxType:"APITypeMemberNames"}))," for the layer and use it to access the pre-populated parameters for that layer in the appropriate dictionary of the ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_qt:!0,mdxType:"APITypeMemberNames"})),". You can then modify individual properties for taking that layer offline."),(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-swift"},"//get the offline map parameter key for a feature layer\nlet key = AGSOfflineMapParametersKey(layer:featureLayer)\n//return the generate geodatabase parameters from the parameter overrides dictionaries\nlet generateGDBParams = self.generateParameterOverrides.generateGeodatabaseParameters[key]\n//\n//Do not return attachments for this feature layer\ngenerateGDBParams?.returnAttachments = false\n"))),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(l,{source:"../../../net/offline-maps-scenes-and-data/code/OfflineMapOnDemand.xaml.cs",section:"GdbParamOverride",language:"cs",mdxType:"CodeBlock"},'using Esri.ArcGISRuntime.Geometry;\nusing Esri.ArcGISRuntime.Mapping;\nusing Esri.ArcGISRuntime.Portal;\nusing Esri.ArcGISRuntime.Tasks.Offline;\nusing Esri.ArcGISRuntime.UI;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace ArcGISRuntime.DevGuide.Topics.OfflineMapOnDemand;\n\n//@@Start(HideTopicAttributes)\n[ArcGISRuntime.Snippets.Shared.Attributes.Topic(\n    title: "Download an offline map (on-demand)",\n    chapter: "Offline maps, scenes, and data",\n    mdxName: "download-an-offline-map-on-demand",\n    description: "Define the area and parameters of a map to be taken offline. Then create the map on-demand to support an offline workflow.",\n    order: 2,\n    snippetsToMigrate: 0,\n    missingSnippets: 0,\n    tags: new[] { "OfflineMapCapabilities ", "GenerateOfflineMapParameters ", "GenerateOfflineMapJob " })]\n//@@End(HideTopicAttributes)\npublic partial class OfflineMapOnDemand\n{\n    public OfflineMapOnDemand()\n    {\n        InitializeComponent();\n        Snippets();\n    }\n\n    private void Snippets()\n    {\n        // Hide the map loading progress indicator.\n        loadingIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n        // When the map view unloads, try to clean up existing output data folders.\n        MyMapView.Unloaded += (s, e) =>\n        {\n            // Find output mobile map folders in the temp directory.\n            string[] outputFolders = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%TEMP%"), "NapervilleWaterNetwork*");\n\n            // Loop through the folder names and delete them.\n            foreach (string dir in outputFolders)\n            {\n                try\n                {\n                    // Delete the folder.\n                    Directory.Delete(dir, true);\n                }\n                catch (Exception)\n                {\n                    // Ignore exceptions (files might be locked, for example).\n                }\n            }\n        };\n\n        MyMapView.Map = new Map(new Uri(@"https://arcgisruntime.maps.arcgis.com/home/item.html?id=acc027394bc84c2fb04d1ed317aac674"));\n    }\n\n    GenerateOfflineMapJob _offlineMapJob;\n    private async Task OnDemandMap(string pathToOutputPackage, FeatureLayer streetsLayer)\n    {\n        OfflineMapTask takeMapOfflineTask;\n\n        // Show the progress indicator while the job is running.\n        busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n\n// @@Start(CreateOfflineMapTask) line 77\n// Get a web map item from ArcGIS Online using its ID.\nvar agol = await ArcGISPortal.CreateAsync();\nvar webmapItem = await PortalItem.CreateAsync(agol, "acc027394bc84c2fb04d1ed317aac674");\n\n// Create a map from the web map item.\nvar onlineMap = new Map(webmapItem);\n\n// Create an OfflineMapTask from the map ...\ntakeMapOfflineTask = await OfflineMapTask.CreateAsync(onlineMap);\n// ... or a web map portal item.\n//takeMapOfflineTask = await OfflineMapTask.CreateAsync(webmapItem);\n// @@End(CreateOfflineMapTask)\n\n// @@Start(SetOfflineMapParameters) line 315\n// Create default parameters for the task.\nEnvelope areaOfInterest = GetAreaOfInterest();\nvar parameters = await takeMapOfflineTask.CreateDefaultGenerateOfflineMapParametersAsync(areaOfInterest);\n\n// Limit the maximum scale to 5000 but take all the scales above (use default of 0 as the MinScale).\nparameters.MaxScale = 5000;\n\n// Set attachment options.\nparameters.AttachmentSyncDirection = AttachmentSyncDirection.Upload;\nparameters.ReturnLayerAttachmentOption = ReturnLayerAttachmentOption.EditableLayers;\n\n// Update the map title to contain the region.\nparameters.ItemInfo.Title = parameters.ItemInfo.Title + " (Central)";\n// @@End(SetOfflineMapParameters)\n\n        await CheckOfflineMapCaps(takeMapOfflineTask, parameters);\n\n\n// @@Start(GenerateOfflineMapJob) line 501\n// Create the job to generate an offline map, pass in the parameters and a path to store the map package.\nGenerateOfflineMapJob offlineMapJob = takeMapOfflineTask.GenerateOfflineMap(parameters, pathToOutputPackage);\n// @@End(GenerateOfflineMapJob) \n\n        var offlineMapParamOverrides = await GetParameterOverrides(takeMapOfflineTask, parameters, streetsLayer);\n\n\n// @@Start(GenerateOfflineMapJobWithOverrides) line 544\n// Create the job to generate an offline map, pass in the parameters, a path to store the map package, and overrides.\nGenerateOfflineMapJob offlineMapJobWithOverrides = takeMapOfflineTask.GenerateOfflineMap\n(parameters, pathToOutputPackage, offlineMapParamOverrides);\n// @@End(GenerateOfflineMapJobWithOverrides)\n\n\n        _offlineMapJob = offlineMapJob;\n        // Handle the progress changed event for the job.\n        _offlineMapJob.ProgressChanged += OfflineMapJob_ProgressChanged;\n\n        await GetOfflineMapResult();\n    }\n\n    private async Task CheckOfflineMapCaps(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CheckOfflineMapCapabilities) line 144\nOfflineMapCapabilities results = await takeMapOfflineTask.GetOfflineMapCapabilitiesAsync(parameters);\nif (results.HasErrors)\n{\n    foreach (var layerCapability in results.LayerCapabilities)\n    {\n        // Report layer errors ...\n    }\n\n    foreach (var tableCapability in results.TableCapabilities)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(CheckOfflineMapCapabilities)\n    }\n\n    private async Task CreateOfflineMapItemInfo(PortalItem webMapItem, GenerateOfflineMapParameters parameters)\n    {\n\n// @@Start(CreateOfflineMapItemInfo) line 926\n// Create a new OfflineMapItemInfo to store metadata for the map.\nOfflineMapItemInfo itemInfo = new OfflineMapItemInfo();\n\n// Create new thumbnail from the map\nRuntimeImage thumbnailImage = await MyMapView.ExportImageAsync();\n\n// Provide a better title and thumbnail to describe the map extent.\nitemInfo.Thumbnail = thumbnailImage;\nitemInfo.Title = "Water network (Central)";\n\n// Copy basic info from the source item.\nitemInfo.Snippet = webMapItem.Snippet;\nitemInfo.Description = webMapItem.Description;\nitemInfo.AccessInformation = webMapItem.AccessInformation;\n\n// Add some tags.\nitemInfo.Tags.Add("Water network");\nitemInfo.Tags.Add("Data validation");\n\n// Apply the metadata to the offline map parameters.\nparameters.ItemInfo = itemInfo;\n// @@End(CreateOfflineMapItemInfo)\n    }\n\n    private async Task<GenerateOfflineMapParameterOverrides> GetParameterOverrides(OfflineMapTask takeMapOfflineTask, GenerateOfflineMapParameters parameters, FeatureLayer streetsLayer)\n    {\n\n// @@Start(OfflineMapParamOverrides) - line 1042\n// Get the offline map parameter overrides from the map task (pass in the task parameters).\nGenerateOfflineMapParameterOverrides offlineMapParamOverrides =\nawait takeMapOfflineTask.CreateGenerateOfflineMapParameterOverridesAsync(parameters);\n\n// Get the dictionary of parameter overrides for exporting a tile cache.\nIDictionary<OfflineMapParametersKey, ExportTileCacheParameters> tileCacheParamOverrides =\nofflineMapParamOverrides.ExportTileCacheParameters;\n// Get the dictionary of parameter overrides for exporting vector tiles.\nIDictionary<OfflineMapParametersKey, ExportVectorTilesParameters> vectorTileParamOverrides =\nofflineMapParamOverrides.ExportVectorTilesParameters;\n// Get the dictionary of parameter overrides for generating a geodatabase.\nIDictionary<OfflineMapParametersKey, GenerateGeodatabaseParameters> geodatabaseParamOverrides =\nofflineMapParamOverrides.GenerateGeodatabaseParameters;\n// TODO: Override parameter values as needed.\n// @@End(OfflineMapParamOverrides)\n\n// @@Start(GdbParamOverride) line 1130\n// Create a dictionary key for the desired parameter override.\nOfflineMapParametersKey streetsParameterKey = new OfflineMapParametersKey(streetsLayer);\n\n// Get one generate geodatabase parameter overrides.\nGenerateGeodatabaseParameters streetsGdbParams = geodatabaseParamOverrides[streetsParameterKey];\n\n// Don\'t return attachments for this layer.\nstreetsGdbParams.ReturnAttachments = false;\n// @@End(GdbParamOverride)\n\n        return offlineMapParamOverrides;\n    }\n\n    private async Task GetOfflineMapResult()\n    {\n        try\n        {\n// @@Start(GetOfflineMapResult) line 619\n// Generate the offline map and download it.\nGenerateOfflineMapResult offlineMapResult = await _offlineMapJob.GetResultAsync();\n\nif (!offlineMapResult.HasErrors)\n{\n    // Job completed successfully and all content was generated.\n    Console.WriteLine("Map " + offlineMapResult.MobileMapPackage.Item.Title +\n        " was saved to " + offlineMapResult.MobileMapPackage.Path);\n\n    // Show the offline map in a MapView.\n    MyMapView.Map = offlineMapResult.OfflineMap;\n}\nelse\n{\n    // Job is finished but one or more layers or tables had errors.\n    foreach (var layerError in offlineMapResult.LayerErrors)\n    {\n        // Report layer errors ...\n    }\n    foreach (var layerError in offlineMapResult.TableErrors)\n    {\n        // Report table errors ...\n    }\n}\n// @@End(GetOfflineMapResult)\n        }\n        catch (Exception ex)\n        {\n            ShowMessage(ex.Message);\n        }\n        finally\n        {\n            // Hide the activity indicator when the job is done.\n            busyIndicator.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Hide the "Take map offline" button.\n            takeOfflineArea.Visibility = Microsoft.UI.Xaml.Visibility.Collapsed;\n\n            // Show a message that the map is offline.\n            messageArea.Visibility = Microsoft.UI.Xaml.Visibility.Visible;\n        }\n    }\n\n    private void OfflineMapJob_ProgressChanged(object sender, EventArgs e)\n    {\n        // Get the job.\n        GenerateOfflineMapJob job = sender as GenerateOfflineMapJob;\n\n        // Dispatch to the UI thread.\n        DispatcherQueue.TryEnqueue(Microsoft.UI.Dispatching.DispatcherQueuePriority.Normal, () =>\n        {\n            // Show the percent complete and update the progress bar.\n            Percentage.Text = job.Progress > 0 ? job.Progress.ToString() + " %" : string.Empty;\n            progressBar.Value = job.Progress;\n        });\n    }\n\n    private void ShowMessage(string message)\n    {\n        var msgDialog = new MessageDialog2(message);\n        _ = msgDialog.ShowAsync();\n    }\n\n    private Envelope GetAreaOfInterest()\n    {\n        return MyMapView.GetCurrentViewpoint(ViewpointType.BoundingGeometry).TargetGeometry as Envelope;\n    }\n\n    private void TakeMapOfflineButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        string packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork");\n        int num = 1;\n        while (Directory.Exists(packagePath))\n        {\n            packagePath = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), @"NapervilleWaterNetwork" + num.ToString());\n            num++;\n        }\n\n        // Create the output directory.\n        Directory.CreateDirectory(packagePath);\n\n        var overrideLayer = MyMapView.Map.OperationalLayers[3] as FeatureLayer;\n        _ = OnDemandMap(packagePath, overrideLayer);\n    }\n\n    private async void CancelJobButton_Click(object sender, Microsoft.UI.Xaml.RoutedEventArgs e)\n    {\n        // The user canceled the job.\n        await _offlineMapJob.CancelAsync();\n    }\n}')),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"//get the offline map parameter key for a feature layer\nOfflineMapParametersKey parametersKey = new OfflineMapParametersKey(featureLayer);\n\n//return the generate geodatabase parameters from the parameter overrides dictionaries\nMap<OfflineMapParametersKey, GenerateGeodatabaseParameters> gdbParametersMap = \n  overrides.getGenerateGeodatabaseParameters();\nGenerateGeodatabaseParameters gdbParameters = gdbParametersMap.get(parametersKey);\ngdbParameters.setReturnAttachments(false);\n"))),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"//get the offline map parameter key for a feature layer\nOfflineMapParametersKey parametersKey = new OfflineMapParametersKey(featureLayer);\n\n//return the generate geodatabase parameters from the parameter overrides dictionaries\nMap<OfflineMapParametersKey, GenerateGeodatabaseParameters> gdbParametersMap = \n  overrides.getGenerateGeodatabaseParameters();\nGenerateGeodatabaseParameters gdbParameters = gdbParametersMap.get(parametersKey);\ngdbParameters.setReturnAttachments(false);\n"))),(0,r.mdx)("p",{parentName:"li"},"The ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapParameterOverrides_qt:!0,mdxType:"APITypeMemberNames"}))," also includes two lists which can be modified to specify which ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{Layer_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{Layer_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{Layer_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{Layer_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{Layer_qt:!0,mdxType:"APITypeMemberNames"}))," and ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{ServiceFeatureTable_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{ServiceFeatureTable_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{ServiceFeatureTable_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{ServiceFeatureTable_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{ServiceFeatureTable_qt:!0,mdxType:"APITypeMemberNames"}))," objects should not have content downloaded but should instead access the original online data whenever a network connection is available (see ",(0,r.mdx)("a",{parentName:"p",href:"#retain-online-services"},"Retain online services")," for more details)."))),(0,r.mdx)("p",null,"After defining your overrides, you can create a ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{GenerateOfflineMapJob_qt:!0,mdxType:"APITypeMemberNames"}))," by calling ",(0,r.mdx)(o,{c:"sdk == 'ios'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_generateOfflineMap_ios:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'net'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_generateOfflineMap_net:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'android'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_generateOfflineMap_android:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'java'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_generateOfflineMap_java:!0,mdxType:"APITypeMemberNames"})),(0,r.mdx)(o,{c:"sdk == 'qt'",mdxType:"If"},(0,r.mdx)(i.Z,{OfflineMapTask_generateOfflineMap_qt:!0,mdxType:"APITypeMemberNames"}))," on the offline map task, supplying the parameters and the overrides.")),(0,r.mdx)(o,{c:n.considerations,mdxType:"If"},(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Advanced symbols are supported only if they are defined in the original service. Any overrides with advanced symbols will result in empty symbols in an offline map.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"Area-of-interest geometries that cross the dateline are not currently supported.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},"If more than one feature layer in a map refers to the same feature service endpoint, only one feature layer will be taken offline. The other feature layers will raise an error.")))))}c.isMDXComponent=!0}}]);